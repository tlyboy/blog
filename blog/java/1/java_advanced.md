---
title: Java 高级
date: 2022-4-1
categories:
  - Java 笔记
tags:
  - Java
---

## 1. 面向对象基础

### 1. 类和对象

#### 1. 什么是对象

万物皆对象，客观存在的事物皆为对象

#### 2. 什么是面向对象

面向对象(Object Oriented)是软件开发方法，一种编程范式。

#### 3. 什么是类

类是对显示生活中一类具有**共同属性**和**行为**的事物的抽象

**类的特点：**

- 类是对象的数据类型
- 类是具有相同属性的行为的一组对象的集合

#### 4. 什么是对象的属性

**属性** ：对象具有的各种特征，每个对象的每个**属性**都拥有特定的**值**

#### 5. 什么是对象的行为

**行为**：对象能够执行的操作

#### 6.类和对象的关系

**类**：类是对现实生活中一类具有共同属性和行为的事物的抽象

**对象**：是能够看得到摸得到的真实存在的实体

#### 7. 类的定义

类的重要性：是 Java 程序的基本组成单位

类是什么：是对现实生活中一类具有**共同属性**和**行为**的事物的抽象，确定对象将会拥有的属性和行为

类的组成：**属性**和**行为**

- 属性：在类中通过**成员变量**来体现（类中方法外的变量）
- 行为：在类中通过**成员方法**来体现（和前面的方法相比去掉 static 关键字即可）

**类的定义步骤：**

1. 定义类
2. 编写类的成员变量
3. 编写类的成员方法

```java
public class 类名 {
    //成员变量
    变量1的数据类型 变量1;
    变量2的数据类型 变量2;
    ...
    //成员方法
    方法1;
    方法2;
    ...
}
```

#### 8. 对象的使用

创建对象

- 格式：`类名 对象名 = new 类名();`

使用对象

1. **使用成员变量**
   - 格式：`对象名.变量名`
2. **使用成员方法**
   - 格式：`对象名.方法名()`

### 2. 成员变量和局部变量

#### 1. 什么是成员变量和局部变量

成员变量：类中方法外的变量

局部变量：方法中的变量

#### 2. 成员变量和局部变量区别

| 区别           | 成员变量                                   | 局部变量                                       |
| -------------- | ------------------------------------------ | ---------------------------------------------- |
| 类中位置不同   | 类中方法外                                 | 方法内或者方法声明上                           |
| 内存中位置不同 | 堆内存                                     | 栈内存                                         |
| 生命周期不同   | 随着对象的存在而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的调用完毕而消失 |
| 初始化值不同   | 有默认的初始化值                           | 没有默认的初始化值，必须先定义，赋值，才能使用 |

### 3. 封装

#### 1. private 关键字

- 是一个权限修饰符
- 可以修饰成员（成员变量和成员方法）
- 作用是保护成员不被别的类使用，被 `private` 修饰的成员只在本类中才能访问

针对 `private` 修饰的成员变量，如果需要被其他类使用，提供相应的操作

- 提供“ `get 变量名()`”方法，用于获取成员变量的值，方法用 `public` 修饰
- 提供“ `set 变量名(参数)`”方法，用于设置成员变量的值，方法用 `public` 修饰

#### 2. private 关键字的使用

一个标准类的编写：

- 把成员变量用 `private` 修饰
- 提供对应的 `getXxx()/setXxx()` 方法

#### 3. this 关键字

1. this 修饰的变量用于指代成员变量
   - 方法的形参如果与成员变量同名，不带 this 修饰的变量指的是形参，而不是成员变量
   - 方法的形参没有与成员变量同名，不带 this 修饰的变量指的是成员变量
2. 什么时候使用 this 呢？**解决局部变量隐藏成员变量**
3. this：代表所在类的对象引用
   - 记住：方法被哪个对象调用，this 就代表哪个对象

#### 5. 封装

##### **1. 封装概述**

是面向对象三大特征之一（**封装，继承，多态**）
是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的

##### **2. 封装原则**

将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量 `private`，提供对应的 `getXxx()/setXxx()` 方法

##### **3. 封装好处**

通过方法来控制成员变量的操作，提高了代码的安全性

把代码用方法进行封装，提高了代码的复用性

### 4. 构造方法

#### 1. 构造方法概述

构造方法是一种特殊的方法

作用：创建对象

格式：

```java
public class 类名 {
    修饰符 类名 (参数) {
    }
}
```

功能：主要是完成对象数据的初始化

#### 2. 构造方法的注意事项

1. 构造方法的创建

- 如果没有定义构造方法，系统将给出一个**默认**的**无参数构造方法**
- 如果定义了构造方法，系统将不再提供默认的构造方法

2. 构造方法的重载

- 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法

3. 推荐的使用方式

- **无论是否使用，都手工书写无参数构造方法**

#### 3. 标准类的制作

1. 成员变量
   - 使用 `private` 修饰
2. 构造方法
   - 提供一个无参构造方法
   - 提供一个带多个参数的构造方法
3. 成员方法
   - 提供每一个成员变量对应的 `setXxx()/getXxx()`
   - 提供一个显示对象信息的 `show()`
4. 创建对象并为其成员变量赋值的两种方式
   - 无参构造方法创建对象后使用 `setXxx()` 赋值
   - 使用带参构造方法直接创建带有属性值的对象

## 2. String

### 1. API

#### 1. API 概述

**API**(**A**pplication **P**rogramming **I**nterface)：应用程序编程接口

Java API：指的就是 JDK 中提供的各种功能的 Java 类

#### 2. 如何使用帮助文档

1. 右键打开该文档
2. 找到索引选项卡中的输入框
3. 在输入框中输入 Random
4. 看在哪个包下
5. 看类的描述
6. 看构造方法
7. 看成员方法

#### 3. API 使用练习

::: warning
**注意：**

**调用方法的时候，如果方法有明确的返回值，我们用变量接收**

**可以手动完成，也可以使用快捷键的方式完成(Ctrl + Alt + V)**
:::

### 2. String

#### 1. String 概述

String 类在 `java.lang` 包下，所以使用的时候不需要导包

`String` 类代表**字符串**，Java 程序中的所有字符串文字（例如 "abc"）

也就是说，**Java 程序中所有的双引号字符串，都是 String 类的对象**

字符串的特点

- 字符串不可变，它们的值在创建后不能被更改
- 虽然 String 的值是不可变的，但它们可以被共享
- 字符串效果上相当于字符数组（`char[]`），但是底层原理是字节数组（`byte[]`）

::: tip
**JDK 8 及以前是字符数组，JDK 9 及以后是字节数组**
:::

#### 2. String 构造方法

| 方法名                       | 说明                                       |
| ---------------------------- | ------------------------------------------ |
| `public String ()`           | 创建一个空白字符串对象，不含有任何内容     |
| `public String (char[] chs)` | 根据字符数组的内容，来创建字符串对象       |
| `public String (byte[] bys)` | 根据字节数组的内容，来创建字符串对象       |
| `String s = "abc";`          | 直接赋值的方式创建字符串对象，内容就是 abc |

#### 3. String 对象的特点

1. 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

```java
char[] chs = {'a', 'b', 'c'};
String s1 = new String(chs);
String s2 = new String(chs);
```

上面的代码中，JVM 会首先创建一个字符数组，然后每一次 new 的时候都会有一个新的地址，只不过 s1 和 s2 参考的字符串内容是相同的

2. 以""方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都会只建立一个 String 对象，并在字符串池中维护

```java
String s3 = "abc";
String s4 = "abc";
```

在上面的代码中，针对第一行代码，JVM 会建立一个 String 对象放在字符串池中，并给 s3 参考;

第二行则让 s4 直接参考字符串池中的 String 对象，也就是说它们本质上是同一个对象

#### 4. 字符串的比较

使用`==`做比较

- 基本类型：比较的是**数据值**是否相同
- 引用类型：比较的是**地址值**是否相同

字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫：`equals()`

- `public boolean equals (Object anObject)`：将此字符串与指定对象进行比较。由于我们比较的是字符串对象，所以参数直接传递一个字符串

#### 5. 通过帮助文档查看 String 中的方法

| 方法名                                    | 说明                                             |
| ----------------------------------------- | ------------------------------------------------ |
| `public boolean equals (Object anObject)` | 比较字符串的内容，严格区分大小写（用户名和密码） |
| `public char charAt (int index)`          | 返回指定索引处的 char 值                         |
| `public int length()`                     | 返回此字符串的长度                               |

### 3. StringBuilder

#### 1. StringBuilder 概述

StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器

这里的可变指的是 StringBuilder 对象中的内容是可变的

**`String` 和 `StringBuilder` 的区别**

- String：内容是不可变的
- StringBuilder：内容是可变的

#### 2. StringBuilder 构造方法

| 方法名                             | 说明                                       |
| ---------------------------------- | ------------------------------------------ |
| `public StringBuilder()`           | 创建一个空白可变字符串对象，不含有任何内容 |
| `public StringBuilder(String str)` | 根据字符串的内容，来创建可变字符串对象     |

#### 3. StringBuilder 的添加和反转方法

| 方法名                                   | 说明                     |
| ---------------------------------------- | ------------------------ |
| `public StringBuilder append (任意类型)` | 添加数据，并返回对象本身 |
| `public StringBuilder reverse ()`        | 返回相反的字符序列       |

#### 4. StringBuilder 和 String 相互转换

1. StringBuilder 转换为 String

   `public String toString()`：通过 toString()就可以实现把 StringBuilder 转换为 String

2. String 转换为 StringBuilder

   `public StringBuilder(String s)`：通过构造方法就可以实现把 String 转换为 StringBuilder

#### 5. 通过帮助文档查看 StringBuilder 中的方法

| 方法名                                   | 说明                                                     |
| ---------------------------------------- | -------------------------------------------------------- |
| `public StringBuilder append (任意类型)` | 添加数据，并返回对象本身                                 |
| `public StringBuilder reverse ()`        | 返回相反的字符序列                                       |
| `public String toString()`               | 通过 toString() 就可以实现把 StringBuilder 转换为 String |

## 3. 集合基础

### 1. 集合概述

编程的时候如果要存储多个数据，使用长度固定的数组存储格式，不一定满足我们的需求，更适应不了变化的需求，那么此时该如何选择呢？

集合的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变

集合类有很多，目前我们先学习一个：`ArrayList`

`ArrayList<E>`：

- 可调整大小的数组实现
- \<E\> 是一种特殊的数据类型，泛型。

**怎么用呢？**

再出现 E 的地方我们使用引用数据类型替换即可

举例：

- `ArrayList<String>`
- `ArrayList<Student>`

### 2. ArrayList 构造方法和添加方法

| 方法名                                   | 说明                           |
| ---------------------------------------- | ------------------------------ |
| `public ArrayList()`                     | 创建一个空的集合对象           |
| `public boolean add (E e)`               | 将指定的元素追加到此集合的末尾 |
| `public void add (int index, E element)` | 在此集合中的位置插入指定的元素 |

### 3. ArrayList 集合常用方法

| 方法名                                | 说明                                   |
| ------------------------------------- | -------------------------------------- |
| `public boolean remove (Object o)`    | 删除指定的元素，返回删除是否成功       |
| `public E remove (int index)`         | 删除指定索引处的元素，返回被删除的元素 |
| `public E set (int index, E element)` | 修改指定索引处的元素，返回被修改的元素 |
| `public E get (int index)`            | 返回指定索引处的元素                   |
| `public int size ()`                  | 返回集合中的元素个数                   |

## 4. 继承

### 1. 继承概述

继承格式

- 格式：`public class 子类名 extends 父类名 { }`
- 范例：`public class Zi extends Fu { }`
- Fu：是父类，也被称为基类、超类
- Zi：是子类，也被称为派生类

继承中子类的特点：

- 子类可以有父类的内容
- 子类还可以有自己特有的内容

### 2. 继承的好处和弊端

继承的好处

- 提高了代码的**复用性**（多个类相同的成员可以放到同一个类中）
- 提高了代码的**维护性**（如果方法的代码需要修改，修改一处即可）

继承的弊端

- 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性

什么时候使用继承？

- 继承体现的关系：**is a**
- 假设法：我有两个类 A 和 B，如果他们满足 A 是 B 的一种，或者 B 是 A 的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不能滥用继承
- 举例：苹果和水果，猫和动物，猫和狗

### 3. 继承中变量的访问特点

在子类中访问一个变量

- 子类局部范围查找
- 子类成员范围查找
- 父类成员范围查找
- 如果都没有就报错（不考虑父亲的父亲...）

### 4. super

`super` 关键字的用法和 `this` 关键字的用法相似

- `this`：代表本类对象的引用
- `super`：代表父类存储空间的标识（可以理解为父亲对象引用）

::: tip
this 关键字指向调用该方法的对象

一般我们是在当前类中使用 this 关键字，所以我们常说 this 代表本类对象的引用
:::

| 关键字  | 访问成员变量                      | 访问构造方法                  | 访问成员方法                           |
| ------- | --------------------------------- | ----------------------------- | -------------------------------------- |
| `this`  | `this.成员变量` 访问本类成员变量  | `this(...)` 访问本类构造方法  | `this.成员方法(...)` 访问本类成员方法  |
| `super` | `super.成员变量` 访问父类成员变量 | `super(...)` 访问父类构造方法 | `super.成员方法(...)` 访问父类成员方法 |

### 5. 继承中构造方法的访问特点

子类中所有的构造方法默认都会访问父类中无参的构造方法为什么呢?

- 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化
- 每一个子类构造方法的第一条语句默认都是：`super()`

如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢?

- 通过使用 super 关键字去显示的调用父类的带参构造方法

**推荐：自己给出无参构造方法**

### 6. 继承中成员方法的访问特点

通过子类对象访问一个方法

- 子类成员范围找
- 父类成员范围找
- 如果都没有就报错（不考虑父亲的父亲...）

### 7. 方法重写

方法重写概述

- 子类中出现了和父类中一模一样的方法声明

方法重写的应用

- 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容
- 练习：手机类和新手机类

`@Override`

- 是一个注解（注解后面会学习）
- 可以帮助我们检查重写方法的方法声明的正确性

### 8. 方法重写的注意事项

- 私有方法不能被重写（父类私有成员子类是不能继承的）子类方法访问
- 权限不能更低（public > 默认 > 私有）

### 9. Java 中继承的注意事项

- Java 中只支持单继承，不支持多继承
- Java 中类支持多层继承

## 5. 修饰符

### 1. 包

#### 1. 包的概述和使用

其实就是文件夹

作用：对类进行分类管理

包的定义格式

- 格式：`package 包名;` （多级包用的）

带包的 Java 类编译和执行

- 手动建包：

  按照以前的格式编译 Java 文件

  手动创建包

  把 class 文件放到包的最里面

  带包执行

- 自动建包：`java -d HelloWorld.java`

### 2. 导包

使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了

为了简化导包的操作，Java 就提供了导包的功能

导包的格式

- 格式：`import 包名;`

### 3. 修饰符

#### 1. 修饰符的分类

- 权限修饰符
- 状态修饰符

#### 2. 权限修饰符

|   修饰符    | 同一个类中 | 同一个包中子类无关类 | 不同包的子类 | 不同包的无关类 |
| :---------: | :--------: | :------------------: | :----------: | :------------: |
|  `private`  |     ✔      |                      |              |                |
|    默认     |     ✔      |          ✔           |              |                |
| `protected` |     ✔      |          ✔           |      ✔       |                |
|  `public`   |     ✔      |          ✔           |      ✔       |       ✔        |

#### 3. 状态修饰符

- `final`（最终态）
- `static`（静态）

#### 4. final

`final` 关键字是最终的意思，可以修饰成员方法，成员变量，类

`final` 修饰的特点

- 修饰方法：表明该方法是最终方法，**不能被重写**
- 修饰变量：表明该变量是常量，**不能再次被赋值**
- 修饰类：表明该类是最终类，**不能被继承**

#### 5. final 修饰局部变量

变量是基本类型：final 修饰指的是基本类型的**数据值**不能发生改变

变量是引用类型：final 修饰指的是引用类型的**地址值**不能发生改变，但是地址里面的内容是可以发生改变的

#### 6. static

`static` 关键字是静态的意思，可以修饰成员方法，成员变量

`static` 修饰的特点

- 被类的所有对象共享

  这也是我们判断是否使用静态关键字的条件

- 可以通过类名调用

  当然也可以通过对象名调用

  **推荐使用类名调用**

#### 7. static 访问特点

非静态的成员方法

- 能访问静态的成员变量
- 能访问非静态的成员变量
- 能访问静态的成员方法
- 能访问非静态的成员方法

静态的成员方法

- 能访问静态的成员变量
- 能访问静态的成员方法

**总结成一句话就是：静态成员方法只能访问静态成员**

## 6. 多态

### 1. 多态概述

同一个对象，在不同时刻表现出来的不同形态

<br>

举例：猫

我们可以说猫是猫：`猫 cat = new 猫();`

我们也可以说猫是动物：`动物 animal = new 猫();`

这里猫在不同的时刻表现出了不同的形态，这就是多态

<br>

多态的前提和体现

- 有继承/实现关系
- 有方法重写
- 有父类引用指向子类对象

### 2. 多态中成员访问的特点

- **成员变量**：编译看左边，指向看左边
- **成员方法**：编译看左边，执行看右边

<br>

为什么成员变量和成员方法的访问不一样呢？

- 因为成员方法有重写，而成员变量没有

### 3. 多态的好处和弊端

- 多态的好处：提高了程序的扩展性

  具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作

- 多态的弊端：不能使用子类的特有功能

### 4. 多态中的转型

- 向上转型

  从子到父

  父类引用指向子类对象

- 向下转型

  从父到子

  父类引用转为子类对象

## 7. 抽象类

### 1. 抽象类描述

在 Java 中，一个**没有方法体**的方法应该定义为**抽象方法**，而类中如果有**抽象方法**，该类必须定义为**抽象类**

### 2. 抽象类的特点

- 抽象类和抽象方法必须使用 `abstract` 关键字修饰

  `public abstract class 类名{}`

  `public abstract void eat ();`

- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类

- 抽象类不能实例化

  抽象类如何实例化呢？通过子类对象实例化，这也叫抽象类多态

- 抽象类的子类

  要么重写抽象类中的所有抽象方法

  要么是抽象类

### 3. 抽象类的成员特点

- 成员变量

  可以是变量

  也可以是常量

- 构造方法

  有构造方法，但是不能实例化

  那么，构造方法的作用是什么呢？用于子类访问父类数据的初始化

- 成员方法

  可以有抽象方法：限定子类必须完成某些动作

  也可以有非抽象方法：提高代码复用性

## 8. 接口

### 1. 接口概述

接口是一种**公共的规范标准**，只要符合规范标准，大家都可以通用

Java 中的接口更多的体现在**对行为的抽象**

### 2. 接口的特点

- 接口用关键字 `interface` 修饰

  `public interface 接口名 {}`

- 实现接口用 `implements` 表示

  `public class 类名 implements 接口名 {}`

- 接口不能实例化

  接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。

- 接口的实现类

  要么重写接口中的所有抽象方法

  要么是抽象类

### 3. 接口的成员特点

- 成员变量

  只能是常量

  默认修饰符：`public static final`

- 构造方法

  接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在

  一个类如果没有父类，默认继承自 Object 类

- 成员方法

  只能是抽象方法

  默认修饰符：`public abstract`

### 4. 类和接口的关系

- 类和类的关系

  继承关系，只能单继承，但是可以多层继承

- 类和接口的关系

  实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

- 接口和接口的关系

  继承关系，可以单继承，也可以多继承

### 5. 抽象类和接口的区别

- 成员区别

  抽象类：变量，常量；有构造方法，也有非抽象方法

  接口：常量；抽象方法

- 关系区别

  类与类：继承，单继承

  类与接口：实现，可以单实现，也可以多实现

  接口与接口：继承，单继承，多继承

- 设计概念区别

  抽象类：对象抽象，包括属性、行为

  接口：对行为抽象，主要是行为

门和警报的例子

门：都有 `open()` 和 `close()` 两个动作，这个时候，我们可以分别使用抽象类和接口来定义这个抽象概念

```java
//抽象类
public abstract class Door {
    public abstract void open();
    public abstract void close();
}
```

```java
//接口
public interface Door {
    void open();
    void close();
}
```

```java
//抽象类
public abstract class Door {
    public abstract void open();
    public abstract void close();
    public abstract void alarm();
}
```

```java
//接口
public interface Door {
    void open();
    void close();
    void alarm();
}
```

```java
public interface Alarm {
    void alarm();
}
public abstract class Door {
    public abstract void open();
    public abstract void close();
}
public class AlarmDoor extends Door implements Alarm {
    public void open() {
        // ...
    }
    public void close() {
        // ...
    }
    public void alarm() {
        // ...
    }
}
```

在这里，我们再次强调抽象类是对事物的抽象，而接口是对行为的抽象

## 9. 形参和返回值

### 1. 类名作为形参和返回值

- 方法的形参是类名，其实需要的是该类的对象
- 方法的返回值是类名，其实返回的是该类的对象

### 2. 抽象类名作为形参和返回值

- 方法的形参是抽象类名，其实需要的是该抽象类的子类对象
- 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象

### 3.接口名作为形参和返回值

- 方法的形参是接口名，其实需要的是该接口的实现类对象
- 方法的返回值是接口名，其实返回的是该接口的实现类对象

## 10. 内部类

### 1. 内部类概述

内部类：就是一个类中定义一个类。举例：在一个类 A 的内部定义一个类 B，类 B 就被称为内部类

内部类的定义格式：

- 格式：

```java
public class 类名 {
    修饰符 class 类名 {
    }
}
```

- 范例：

```java
public class Outer {
    修饰符 class Inner {
    }
}
```

内部类的访问特点

- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须包括创建对象

### 2. 成员内部类

按照内部类在类中定义的位置不同，可以分为如下两种形式

- 在类的成员位置：成员内部类
- 在类的局部位置：局部内部类

成员内部类，外界如何创建对象使用呢？

- 格式：外部类名.对象名 对象名 = 外部类对象.内部类对象

### 3. 局部内部类

局部内部类是在方法中定义的类，所有外界是无法直接使用，需要在方法内部创建对象并使用

该类可以直接访问外部类的成员，也可以访问方法内部的局部变量

### 4. 匿名内部类

前提：存在一个类或者接口，这里的类可以是具体类也可以是抽象类

- 格式：

```java
new 类名或者接口名() {
    重写方法;
}
```

### 5. 匿名内部类在开发中的使用

```java
/*
	跳高接口
*/
public interface Jumpping {
    void jump();
}
```

```java
/*
	接口操作类，里面有一个方法，方法的参数是接口名
*/
public class JumppingOperator {
    public void method (Jumpping j) {
        j.jump();
    }
}
```

```java
/*
	测试类
*/
public class JumppingDemo {
    public static void main(String[] args) {
        // 需求：创建接口操作类的对象，调用 method 方法
    }
}
```
