---
title: Java 基础
date: 2022-3-22
categories:
  - Java 笔记
tags:
  - Java
---

## 1. Java 概述

### 1. Java 语言的发展史

#### 1. Java 语言

**语言**：人与人交流沟通的表达方式

**计算机语言**：人与计算机之间进行信息交流的一种特殊语言

::: tip

Java 语言是美国 **Sun** 公司在 1995 年推出的计算机语言

Java 之父：詹姆斯·高斯林（James Gosling）

:::

### 2. Java 语言跨平台原理

#### 1. 平台

指的是操作系统

- Windows
- Mac
- Linux

#### 2. 跨平台

Java 程序可以在任意操作系统上运行

#### 3. 跨平台原理

总结：在需要**运行 Java 程序**的操作系统上，安装一个与操作系统对应的 Java 虚拟机（**JVM Java Virtual Machine**）即可

### 3. JRE 和 JDK

#### 1. JRE（Java Runtime Environment）

是 Java 程序的运行环境，包含 **JVM** 和运行时所需要的核心类库。

我们想要**运行**一个已有的 Java 程序，那么只需安装 **JRE** 即可。

#### 2. JDK（Java Development Kit）

是 Java 程序的开发工具包，包含 **JRE** 和开发人员使用的工具。

其中的开发工具：编译工具（**javac.exe**）和运行工具（**java.exe**）。

我们想要**开发**一个全新的 Java 程序，那么必须安装 **JDK**。

#### 3. JDK、JRE、JVM 的关系

**JDK** 包含 **JRE** 和**开发工具**、**JRE** 含 **JVM** 和**核心类库**。

### 4. JDK 的下载和安装

#### 1. JDK 的下载

通过官方网站获取 JDK

JDK 8：[https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html](https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html)

::: warning 注意

针对不同的操作系统，下载对应的 JDK

:::

#### 2. JDK 的安装

傻瓜式安装，下一步即可。

::: tip 提示

建议安装到 C:\Program Files\Java 目录下。

如果只用一个版本，可以将版本号去除，方便日后更换也不用修改环境变量。

JDK 目录：C:\Program Files\Java\jdk

JRE 目录：C:\Program Files\Java\jre

如果要安装到其他盘下，只需修改盘符即可。

:::

#### 3. JDK 的安装目录

| 目录名称 | 说明                                                                    |
| :------: | ----------------------------------------------------------------------- |
| **bin**  | 该路径下存放了 JDK 的各种工具命令。`javac` 和 `java` 就存放在这个目录。 |
|   conf   | 该路径下存放了 JDK 的相关配置文件。                                     |
| include  | 该路径下存放了一些平台特点的头文件。                                    |
|  jmodes  | 该路径下存放了 JDK 的各种模块。                                         |
|  legal   | 该路径下存放了 JDK 各模块的授权文档。                                   |
|   lib    | 该路径下存放了 JDK 工具的一些补充 JAR 包。                              |

## 2. 第一个程序

### 1. 常用 DOS 命令

#### 1. 打开命令提示符窗口

1. 按下 win + R
2. 输入 cmd
3. 按下回车键

#### 2. 常用命令

| 操作                 | 说明                   |
| -------------------- | ---------------------- |
| 盘符名称：           | 盘符切换。             |
| dir                  | 查看当前路径下的内容。 |
| cd 目录              | 进入单级目录。         |
| cd ..                | 回退到上一级目录。     |
| cd 目录 1\目录 2\... | 进入多级目录。         |
| cd \                 | 回退到盘符目录。       |
| cls                  | 清屏。                 |
| exit                 | 退出命令提示符窗口。   |

### 2. Path 环境变量的配置

#### 1. 为什么要配置 Path 环境变量

开发 Java 程序，需要使用 JDK 提供的开发工具，而这些工具在 JDK 的安装目录的 bin 目录下。

为了在开发 Java 程序的时候，为了能够方便的使用 **javac** 和 **java** 这些命令，我们需要配置 **Path 环境变量**。

#### 2. 如何配置 Path 环境变量

**JAVA_HOME**（新建）：

```text
C:\Program Files\Java\jdk
```

**Path**（添加）：

```text
%JAVA_HOME%\bin
```

::: warning 注意

Path 是添加新的值，不要的原来的值删了。

:::

#### 3. 如何检测配置 Path 环境变量是否成功

在 cmd 中输入 `java` 或者 `javac -version`，出现提示信息。

### 3. HelloWorld 案例

#### 1. Java 程序开发运行流程

开发 Java 程序，需要三个步骤：**编写程序**，**编译程序**，**运行程序**

#### 2. HelloWorld 案例的编写

1. 新建文本文档文件，修改名称为 HelloWorld.java

2. 用记事本打开 HelloWorld 文件，书写程序内容

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}
```

#### 3. HelloWorld 案例的编译和运行

打开命令提示符窗口，进入到 HelloWorld.java 所在的目录。输入指令编译和执行。

编译：javac 文件名.java

范例：`javac HelloWorld.java`

<br>

执行：java 类名

范例：`java HelloWorld`

#### 4. BUG 的解决

1. 具备识别 BUG 的能力

   **多看**

2. 具备分析 BUG 的能力

   **多思考，多查阅资料**

3. 具备解决 BUG 的能力

   **多尝试，多总结**

### 4. HelloWorld 案例常见问题

- 中英文符号的问题

  **英文状态下的分号 —— 中文状态下的分号**

- 单词拼写的问题

  **System —— system**

## 3 .基础语法

### 1. 注释

#### 1. 注释概述

- 注释是在程序**指定位置**添加的**说性明信息**
- 注释不参与程序运行，仅起到**说明作用**

#### 2. 注释分类

- 单行注释

```java
// 注释信息
```

- 多行注释

```java
/* 注释信息 */
```

- 文档注释

```java
/** 注释信息 **/
```

::: tip

文档注释目前用不上，暂不讲解。

:::

### 2. 关键字

#### 1. 关键字概述

**关键字**：就是被 Java 语言赋予了**特定含义的单词**。

#### 2. 关键字的特点

- 关键字的字母**全部小写**。
- 常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观。

### 3. 常量

#### 1. 常量概述

**常量**：在程序运行过程中，其值不可改变的量。

#### 2. 常量分类

|  常量类型  | 说明                 |
| :--------: | -------------------- |
| 字符串常量 | 用双引号括起来的内容 |
|  整数常量  | 不带小数的数字       |
|  小数常量  | 带小数的数字         |
|  字符常量  | 用单引号括起来的内容 |
|  布尔常量  | 布尔值               |
|   空常量   | 一个特殊的值，空值   |

### 4. 数据类型

#### 1. 数据类型

Java 语言是强类型语言，对于每一种数据都给出了明确的数据类型，不同的**数据类型**也分配了不同的**内存空间**，所以它们表示的**数据大小**也是不一样的。

#### 2. 数据类型内存占用情况和取值范围

1. 整数型

   | 关键字 | 内存占用 |                  取值范围                  |
   | :----: | :------: | :----------------------------------------: |
   |  byte  |    1     |                 -128 ~ 127                 |
   | short  |    2     |               -32768 ~ 32767               |
   |  int   |    4     |          -2147483648 ~ 2147483647          |
   |  long  |    8     | -9223372036854775808 ~ 9223372036854775807 |

2. 浮点数

   | 关键字 | 内存占用 |             取值范围              |
   | :----: | :------: | :-------------------------------: |
   | float  |    4     |      1.4E-45 ~ 3.4028235E38       |
   | double |    8     | 4.9E-324 ~ 1.7976931348623157E308 |

3. 字符

   | 关键字 | 内存占用 | 取值范围  |
   | :----: | :------: | :-------: |
   |  char  |    2     | 0 ~ 65535 |

4. 布尔

   | 关键字  | 内存占用 |  取值范围   |
   | :-----: | :------: | :---------: |
   | boolean |    1     | true，false |

### 5. 变量

#### 1.变量概述

**变量**：在程序运行过程中，其值可变的量。

从本质上讲，变量是内存中的一小块区域。

#### 2. 变量定义

- 格式：数据类型 变量名 = 变量值;
- 范例：`int a = 10；`

#### 3. 变量的使用

变量的使用：取值和修改值

- 取值格式：变量名
- 范例：`a`

<br>

- 修改值格式：变量名 = 变量值;
- 范例：`a = 20;`

#### 4. 变量使用的注意事项

- **名字不能重复**
- **变量未赋值，不能使用**
- **long 类型的变量定义的时候，为了防止整数过大，后面要加 L**
- **float 类型的变量定义的时候，为了防止类型不兼容，后面要加 F**

### 6. 标识符

#### 1. 标识符概述

**标识符**：就是给类，方法，变量等起名字的**符号**。

#### 2. 标识符定义规则

- 由**数字**、**字母**、**下划线**（\_）和**美元符**（$）组成
- 不能以数字开头
- 不能是关键字
- 区分大小写

#### 3.常见命名约定

小驼峰命名法：**方法、变量**

- 约定 1：标识符是一个单词的时候，首字母小写
- 范例 1：`name`

<br>

- 约定 2：标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写
- 范例 2：`firstName`

大驼峰命名法：**类**

- 约定 1：标识符是一个单词的时候，首字母大写
- 范例 1：`Student`

<br>

- 约定 2：标识符由多个单词组成的时候，每个单词的首字母大写
- 范例 2：`GoodStudent`

### 7. 类型转换

#### 1. 类型转换分类

- 自动类型转换
- 强制类型转换

#### 2. 自动类型转换

把一个表示数据**范围小的数值**或者**变量**赋值给另一个表示**数据范围大的变量**

范例: `double = 10;`

数据范围从小到大

- byte —— short —— int —— long —— float —— double

- char —— int

#### 3. 强制类型转换

把一个表示数据**范围大的数值**或者**变量**赋值给另一个表示数据**范围小的变量**

- 格式：**目标数据类型 变量名=(目标数据类型)值或者变量;**

## 4. 运算符

### 1. 算数运算符

#### 1. 运算符和表达式

- 运算符：对常量或者变量进行操作的**符号**

- 表达式：

  用**运算符**把常量或者变量连接起来**符合 Java 语法的式子**就可以称为表达式。

  不同运算符合连接的表达式体现的是不同类型的表达式。

- 举例说明：

  int a = 10;

  int b = 20;

  int c = a + b;

  <br>

  **+：是运算符**，并且是算术运算符

  **a + b：是表达式**，由于+是算术运算符，所以这个表达式叫算术表达式

#### 2. 算数运算符

| 符号 | 作用 |
| :--: | :--: |
|  +   |  加  |
|  -   |  减  |
|  \*  |  乘  |
|  /   |  除  |
|  %   | 取余 |

::: warning 注意

**/** 和 **%** 的区别：两个数据做除法，**/** 取结果的**商**，**%** 取结果的**余数**。

整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。

:::

#### 3. 字符的 “+” 操作

拿字符在计算机底层**对应的数值**来进行计算的

**'A' ——> 65 A —— Z 是连续的**

**'a' ——> 97 a —— z 是连续的**

**'0' ——> 48 0 —— 9 是连续的**

算数表达式中**包含多个基本数据类型**的值得时候，整个算数表达式的**类型**会**自动进行提升**。

提升规则：

- byte 类型，short 类型和 char 类型将被提升到 int 类型

- 整个表达式的类型自动提升到表达式中最高等级操作数同样的类型

  等级顺序：byte，short，char ——> int——> long ——> float ——> double

#### 4. 字符串的 “+” 操作

当 “+” 操作中出现字符串时，这个 “+” **是字符串连接符**，而不是算数运算。

- "xxx" + 666

当 “+” 操作中，出现了字符串，就是连接运算符，否则就是算数运算符。当连续进行 “+” 操作时，从左到右逐个执行。

- 1 + 99 + "xxx"

### 2. 赋值运算符

#### 1. 赋值运算符

| 符号 |    作用    |
| :--: | :--------: |
|  =   |    赋值    |
|  +=  |  加后赋值  |
|  -=  |  减后赋值  |
| \*=  |  乘后赋值  |
|  /=  |  除后赋值  |
|  %=  | 取余后赋值 |

### 3. 自增自减运算符

#### 1. 自增自减运算符

| 符号 | 作用 |
| :--: | :--: |
|  ++  | 自增 |
|  --  | 自减 |

::: warning 注意

- \+ \+ 和 \- \- 即可以放在变量的后边，也可以放在变量的前边。

- 单独使用的时候，\+ \+ 和 \- \- 无论是放在变量的前边还是后边，结果是一样的。

- 参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做 \+ \+ 或者 \- \-。

  参与操作的时候，如果放在变量的前边，先拿变量做 \+ \+ 或者 \- \-，后拿变量参与操作。

:::

最常见的用法：**单独使用**

### 4. 关系运算符

#### 1. 关系运算符

| 符号 | 说明                                                              |
| :--: | ----------------------------------------------------------------- |
|  ==  | a==b，判断 a 和 b 的值是否**相等**，成立为 true，不成立为 false   |
|  !=  | a!=b，判断 a 和 b 的值是否**不相等**，成立为 true，不成立为 false |
|  >   | a>b，判断 a 是否**大于** b,成立为 true，不成立为 false            |
|  >=  | a>=b，判断 a 是否**大于等于** b，成立为 true，不成立为 false      |
|  <   | a<b，判断 a 是否**小于** b，成立为 true，不成立为 false           |
|  <=  | a<=b，判断 a 是否**小于等于** b，成立为 true，不成立为 false      |

::: warning 注意

关系运算符的**结果**都是 **boolean** 类型，要么是 true，要么是 false。

千万不要把 “= =” 误写成 “=” 。

:::

### 5. 逻辑运算符

#### 1. 逻辑运算符概述

在数学中，一个数据 x，大于 3，小于 6，我们可以这样来进行表示：**3 < x < 6**。

在 Java 中，需要把上面的式子先进行拆解，再进行合并表达。

- 拆解为：x > 3 和 x < 6
- 合并后：x > 3 && x < 6

&&其实就是一个逻辑运算符。

我们可以这样说，逻辑运算符，是用来**连接关系表达式**的运算符。

当然，逻辑运算符也可以直接**连接布尔类型的常量或者变量**。

#### 2 .逻辑运算符

| 符号 |   作用   | 说明                                               |
| :--: | :------: | -------------------------------------------------- |
|  &   |  逻辑与  | a&b，a 和 b 都是 true，结果为 true，否则为 false   |
|  \|  |  逻辑或  | a\|b，a 和 b 都是 false，结果为 false，否则为 true |
|  ^   | 逻辑异或 | a^b，a 和 b 结果不同为 true，相同为 false          |
|  !   |  逻辑非  | !a，结果和 a 的结果正好相反                        |

#### 3 .短路逻辑运算符

| 符号 |  作用  | 说明                           |
| :--: | :----: | ------------------------------ |
|  &&  | 短路与 | 作用和 & 相同，但是有短路效果  |
| \|\| | 短路或 | 作用和 \| 相同，但是有短路效果 |

::: warning 注意

- 逻辑与 **&** ，无论左边真假，右边都要执行。

  短路与 **&&** ，如果左边为真，右边执行；如果**左边为假，右边不执行**。

- 逻辑或 **|** ，无论左边真假，右边都要执行。

  短路或 **||** ，如果左边为假，右边执行；如果**左边为真，右边不执行**。

最常用的逻辑运算符：**\&\&，\|\|，\!**

:::

### 6. 三元运算符

#### 1. 三元运算符

- 格式：关系表达式 **?** 表达式 1 : 表达式 2;
- 范例:：**a > b ? a : b**;

计算规则：

- 首先计算**关系表达式的值**

- 如果值为 **true，表达式 1 的值**就是运算结果

- 如果值为 **false，表达式 2 的值**就是运算结果

## 5. 数据输入

### 1. Scanner 使用的基本步骤

1. 导包

   ```java
   import java.util.Scanner;
   // 导包的动作必须出现在类定义的上边
   ```

2. 创建对象

   ```java
   Scanner sc = new Scanner(System.in);
   // 上面这个格式里面，只有 sc 是变量名，可以变，其他的都不允许变。
   ```

3. 接受数据

   ```java
   int i = sc.nextInt();
   // 上面这个格式里面，只有 i 是变量名，可以变，其他的都不允许变。
   ```

## 6. 分支语句

### 1.流程控制

#### 1. 流程控制语句分类

- 顺序结构
- 分支结构（`if，switch`）
- 循环结构（`for，while，do ... while`）

#### 2. 顺序结构

顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行,程序中大多数的代码都是这样执行的。

### 2. if 语句

#### 1. if 语句格式 1

格式：

```java
if (关系表达式) {

 语句体;

}
```

执行流程：

1. 首先计算关系表达式的值
2. 如果关系表达式的值为 true 就执行语句体
3. 如果关系表达式的值为 false 就不执行语句体
4. 继续执行后面的语句内容

#### 2. if 语句格式 2

格式：

```java
if (关系表达式) {

 语句体1;

} else {

 语句体2;

}
```

1. 首先计算关系表达式的值
2. 如果关系表达式的值为 true 就执行语句体 1
3. 如果关系表达式的值为 false 就执行语句体 2
4. 继续执行后面的语句内容

#### 4. if 语句格式 3

格式：

```java
if (关系表达式1) {

 语句体1;

} else if (关系表达式2){

 语句体2;

}

 ...

 else {

  语句体n + 1;

}
```

执行流程：

1. 首先计算关系表达式 1 的值
2. 如果值为 true 就执行语句体 1；如果值为 false 就计算关系表达式 2 的值
3. 如果值为 true 就执行语句体 2；如果值为 false 就计算关系表达式 3 的值
4. ...
5. 如果没有任何关系表达式为 true，就执行语句体 n+1。

### 3. switch 语句格式

格式：

```java
switch(表达式){

 case 值1:

  语句体1;

  break;

 case 值2:

  语句体2;

  break;

 default:

  语句体n+1;

  [break;]

}
```

格式说明：

- 表达式：取值为 byte、short、int、char，JDK 5 以后可以是枚举，JDK 7 以后可以是 String。
- case：后面跟的是要和表达式进行比较的值。
- break：表示中断，结束的意思，用来结束 switch 语句。
- default：表示所有情况都不匹配的时候，就执行该处的内容，和 if 语句的 else 相似。

执行流程：

1. 首先计算表达式的值。
2. 依次和 case 后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到 break 就会结束。
3. 如果所有的 case 后面的值和表达式的值都不匹配，就会执行 default 里面的语句体，然后程序结束掉。

## 7. 循环语句

### 1. for 循环语句

#### 1. 循环结构

**特征：**

重复做某件事情

具有明确的开始和结束标志

**循环结构的组成：**

初始化语句：用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样。

条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去。

循环体语句：用于表示循环反复执行的内容，简单说就是循环反复执行的事情。

条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去。

**循环结构对应的语法：**

初始化语句：这里可以是一条或者多条语句，这些语句可以完成一些初始化操作。

条件判断语句：这里使用一个结果为 boolean 类型的表达式，这个表达式能够决定是否执行循环体。

循环体语句：这里可以是任意语句，这些语句反复执行

条件控制语句：这里通常是使用一条语句来改变变量的值，从而达到控制循环是否继续向下执行的效果。

#### 2. for 循环语句格式

格式：

```java
for (初始化语句; 条件判断语句; 条件控制语句) {
    循环体语句;
}
```

执行流程：

1. 执行初始化语句

2. 执行条件判断语句，看其结果是 true 还是 false

   如果是 false，循环结束

   如果是 true，继续执行

3. 执行循环体语句

4. 执行条件控制语句

5. 回到 2 继续

### 2. while 循环语句

#### 1. while 循环语句格式

基本格式：

```java
while (条件判断语句) {
    循环体语句;
}
```

完整格式：

```java
初始化语句;
while (条件判断语句) {
    循环体语句;
    条件控制语句;
}
```

执行流程：

1. 执行初始化语句

2. 执行条件判断语句，看其结果是 true 还是 false

   如果是 false，循环结束

   如果是 true，继续执行

3. 执行循环体语句

4. 执行条件控制语句

5. 回到 2 继续

### 3. do...while 循环语句

#### 1. do...while 循环语句格式

基本格式：

```java
do {
    循环体语句;
} while (条件判断语句);
```

完整格式：

```java
初始化语句;
do {
    循环体语句;
    条件控制语句;
} while (条件判断语句);
```

执行流程：

1. 执行初始化语句

2. 执行循环体语句

3. 执行条件控制语句

4. 执行条件判断语句，看其结果是 true 还是 false

   如果是 false，循环结束

   如果是 true，继续执行

5. 回到 2 继续

#### 2. 三种循环的区别

**三种循环的区别：**

- for 循环和 while 循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）
- do...while 循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）

**for 和 while 的区别：**

- 条件控制语句所控制的自增变量，因为归属 for 循环的语法结构中，在 for 循环结束后，就不能再次被访问到了
- 条件控制语句所控制的自增变量，对于 while 循环来说不归属其语法结构中，在 while 循环结束后，该变量还可以继续使用

死循环格式：

```java
for(;;){ }

while(true){ }

do{ }while(true);
```

**while 的死循环格式是最常用的**

**命令提示符窗口中 Ctrl + C 可以结束死循环**

### 4. 控制跳转语句

#### 1. 跳转控制语句概述

- continue 用来循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行
- break 用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环

### 5. 循环嵌套

#### 1. 循环嵌套概述

语句结构：

- 顺序语句以分好结尾，表示一句话的结束

- 分支语句

  一对大括号表示 if 的整体结构，整体描述一个完整的 if 语句

  一对大括号表示 switch 的整体结构，整体描述一个完整的 switch 语句

- 循环语句

  一对大括号表示 for 的整体结构，整体描述一个完整的 for 语句

  一对大括号表示 while 的整体结构，整体描述一个完整的 while 语句

  do...while 以分号结尾，整体描述一个完整的 do...while 语句

任何语句对外都可以看成是一句话，一句代码

分支语句中包含分支语句称为分支嵌套

循环语句中包含循环语句称为**循环嵌套**

### 6. Random

#### 1. Random

作用：用于产生一个随机数

使用步骤：

1. 导包

   ```java
   import java.util.Random;
   // 导包的动作必须出现在类定义的上面
   ```

2. 创建对象

   ```java
   Random r = new Random();
   // 上面这个格式里面，r 是变量名，可以变，其他的都不允许变
   ```

3. 获取随机数

   ```java
   int number = r.nextInt(10); // 获取数据的范围：[0, 10]包括 0，不包括 10
   // 上面这个格式里面，number 是变量，可以变，数字 10 可以变，其他的都不允许变
   ```

## 8. IDEA

### 1. IDEA 概述和安装

#### 1. IDEA 概述

IDEA 全称**Intellij IDEA**，是用于 Java 语言开发的集成环境，它是世界公认的目前用于 Java 程序开发最好的工具。

**集成环境**：把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。

**IDEA 的下载和安装**

下载：[https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)

安装：傻瓜式安装，建议修改安装路径。

### 2. IDEA 中 HelloWorld

#### 1. IDEA 中 HelloWorld 步骤

1. 创建一个空项目
2. 创建一个新模块
3. 在模块的 src 下创建一个包
4. 在包下创建一个类
5. 在 idea 中执行程序

### 3. IDEA 中内容辅助键和快捷键

#### 1. 内容辅助键

- **快速生成语句**

  快速生成 main() 方法：`psvm`，回车

  快速生成输出语句：`sout`，回车

- **内容辅助键**

  Ctrl + Alt + space（内容提示，代码补全等）

#### 2. 快捷键

- **注释**

  单行：选中代码，Ctrl + /，再来一次，就是取消

  多行：选中代码，Ctrl + shift + /，再来一次，就是取消

- **格式化**

  Ctrl + Alt + L

### 4. IDEA 中模块的操作

#### 1. IDEA 中模块操作分类

- 新建模块
- 删除模块
- 导入模块

## 9. 数组

### 1. 数组定义格式

#### 1. 数组概述

- 一次性声明**大量**用于存储数据的变量
- 要存储的数据通常都是**同类型数据**

#### 2. 什么是数组

数组（array）是一种用于存储**多个相同类型**数据的存储模型

### 3. 数组的定义格式

- 格式一：`数据类型[] 变量名`
- 格式而：`数据类型 变量名[]`

### 2. 数组初始化之动态初始化

#### 1. 数组初始化概述

Java 中的数组必须先初始化，然后才能使用

所谓初始化：就是为数组中的元素分配内存空间，并为每个数组元素赋值

### 2. 数组的初始化方式

- 动态初始化
- 静态初始化

#### 3. 动态初始化

动态初始化：初始化时只指定数组长度，由系统为数组分配初始值

- 格式：`数组类型[] 变量名 = new 数据类型[数组长度];`

### 3. 数组元素访问

#### 1. 数组元素访问

- 数组变量访问方式
- 格式：`数组名`

<br>

- 数组内部保存的数据的访问方式
- 格式：`数组名[索引]`

<br>

- 索引是数组中数据的编号方式
- 作用：索引用于访问数组中的数据使用，`数组名[索引]`等同于变量名，是一种特殊的变量名
- 特征：
  1. 索引从 0 开始
  2. 索引是连续的
  3. 索引逐一增加，每次加 1

### 4. 内存分配

#### 1. Java 中内存分配

Java 程序在运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。

数组在初始化时，会为存储空间添加默认值

- 整数：默认值 0
- 浮点数：默认值 0.0
- 布尔值：默认值 false
- 字符：默认值是空字符
- 引用数据类型：默认值是 `null`

<br>

- 栈内存：存储局部变量

定义在方法中的变量

使用完毕，立即消失

- 堆内存：存储 new 出来的内容（实体，对象）

数组在初始化时，会为存储空间添加默认值

每 new 出来的东西都有一个地址值

使用完毕，会在垃圾回收器空闲时被回收

### 5. 数组初始化之静态初始化

#### 1. 数组初始化之静态初始化

静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度

- 格式：`数据类型[] 变量名 = new 数据类型 [] {数据1, 数据2, 数据3, ...... };`
- 简化格式：`数据类型[] 变量名 = {数据1, 数据2, 数据3, ...... };`

### 6. 数组操作的两个常见小问题

- 索引越界：访问了数组中不存在的索引对应的元素，造成索引越界问题
- 空指针异常：访问的数组已经不再指向堆内存的数据，造成空指针异常
- null：空值，引用数据类型的默认值，表示不指向任何有效对象

### 7. 数组常见操作

#### 1. 遍历

#### 2. 获取数组元素数量

- 格式：数组名.**length**
- 遍历通用格式

#### 3. 获取最值

思路：

1. 定义一个变量，用于保存最大值（或最小值）
2. 取数据中第一个数据作为变量的初始值
3. 与数组中剩余的数据逐个比对

## 10. 方法

### 1. 方法概述

- **方法**是（method）是将具有独立功能的**代码块**组织称为一个整体，使其具有特殊功能的**代码集**

注意：

- 方法必须先创建才可以使用，该过程称为方法定义
- 方法创建后并不是直接运行的，需要手动使用后才执行该过程称为方法调用

### 2. 方法的定义和调用

#### 1. 方法的定义

- 格式：

```java
public static void 方法名 () {
    // 方法体
}
```

#### 2. 方法的调用

- 格式：

```java
方法名();
```

::: warning 注意

- 方法必须先定义后调用，否则程序将报错

:::

### 3. 带参数方法的定义和调用

#### 1. 带参数方法的定义

- 格式

```java
public static void 方法名 (参数) {... ...}
```

- 格式（单个参数）：

```java
public static void 方法名 (数据类型 变量名) {... ...}
```

- 格式（多个参数）：

```java
public static void 方法名 (数据类型 变量名1, 数据类型 变量名2, ......) {... ...}
```

::: warning 注意

- 方法定义时，参数中的**数据类型**与**变量名**都不能缺少，缺少任意一个程序将报错
- 方法定义时，多个参数之间使用逗号（ , ）分隔

:::

#### 2. 带参数方法的调用

- 格式：

```java
方法名(参数);
```

- 格式（单个参数）：

```java
方法名(变量名/常量值);
```

- 格式（多个参数）：

```java
方法名(变量名/常量值1, 变量名/常量值2);
```

::: warning 注意

- 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错

:::

#### 3. 形参和实参

- 形参：方法定义中的参数

  等同于变量定义的格式

- 实参：方法调用中的参数

  等同于使用变量或常量

### 4. 带返回值方法的定义和使用

#### 1. 带返回值方法的定义

- 格式：

```java
public static 数据类型 方法名 (参数) {
    return 数据;
}
```

::: warning 注意

- 方法定义时 return 后面的返回值与方法定义上的数据类型要匹配，否则程序将报错

:::

#### 2. 带返回值方法调用

- 格式 1：

```java
方法名(参数);
```

- 格式 2：

```java
数据类型 变量名 = 方法名(参数);
```

::: warning 注意

- 方法的返回值通常会使用变量接收，否则该返回值将无意义

:::

### 5. 方法的注意事项

#### 1. 方法注意事项

- 方法不能嵌套定义
- void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据

#### 2. 方法的通用格式

- 格式：

```java
public static 返回值类型 方法名 (参数) {
    // 方法体
    return 数据;
}
```

- public static：修饰符，目前先记住这个格式

- 返回值类型：

  方法操作完毕之后返回的数据的数据类型

  如果方法操作完毕，没有数据返回，这里写 void，而且方法体中一般不写 return

- 方法名：调用方法时候使用的标识

- 参数：由数据类型和变量名组成，多个参数之间用逗号隔开

- 方法体：完成功能的代码块

- 定义方法时，要做到**两个明确**

  明确方法返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写 void；如果有，写对应的数据类型

  明确参数：主要是明确参数的类型和数量

- 调用方法时

  void 类型的方法，直接调用即可

  非 void 类型的方法，推荐用变量接收调用

### 6. 方法重载

#### 1. 方法重载概述

方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载。

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同，类型不同或者数量不同

#### 2. 方法重载特点

- 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式
- 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载

### 7. 方法的参数传递

#### 1. 方法参数传递（基本类型）

对于基本数据类型的参数，形式参数的改变，不影响实际参数的值

#### 2. 方法参数传递（引用类型）

对于引用类型的参数，形式参数的改变，影响实际参数的值

## 11. Debug

### 1. Debug 概述

**Debug**：是供程序员使用的程序调试工具，它可以用于**查看程序**的**执行流程**，也可以用于追踪程序执行过程来**调试程序**。

### 2. Debug 操作流程

Debug 调试，又被称为断点调试，断点其实是一个标记，告诉我们从哪里开始看

1. 如何加断点
2. 如何运行加了断点的程序
3. 看哪里
4. 点哪里
5. 如何删除断点

#### 1. 如何加断点

选择要设置断点的代码行，在行号的区域后面点击鼠标左键即可。

#### 2. 如何运行加了断点的程序

在代码区域右键 Debug 执行

#### 3. 看哪里

看 Debugger 窗口

看 Console 窗口

#### 4. 点哪里

点 Step into（F7）这个箭头，也可以直接按 F7

点 stop 结束

#### 5. 如何删除断点

选择要删除的断点，单击鼠标左键即可。

如果是多个断点，可以每一个再点击一次。也可以一次性全部删除。

## 12. 面向对象基础

### 1. 类和对象

#### 1. 什么是对象

万物皆对象，客观存在的事物皆为对象

#### 2. 什么是面向对象

面向对象(Object Oriented)是软件开发方法，一种编程范式。

#### 3. 什么是类

类是对显示生活中一类具有**共同属性**和**行为**的事物的抽象

**类的特点：**

- 类是对象的数据类型
- 类是具有相同属性的行为的一组对象的集合

#### 4. 什么是对象的属性

**属性** ：对象具有的各种特征，每个对象的每个**属性**都拥有特定的**值**

#### 5. 什么是对象的行为

**行为**：对象能够执行的操作

#### 6.类和对象的关系

**类**：类是对现实生活中一类具有共同属性和行为的事物的抽象

**对象**：是能够看得到摸得到的真实存在的实体

#### 7. 类的定义

类的重要性：是 Java 程序的基本组成单位

类是什么：是对现实生活中一类具有**共同属性**和**行为**的事物的抽象，确定对象将会拥有的属性和行为

类的组成：**属性**和**行为**

- 属性：在类中通过**成员变量**来体现（类中方法外的变量）
- 行为：在类中通过**成员方法**来体现（和前面的方法相比去掉 static 关键字即可）

**类的定义步骤：**

1. 定义类
2. 编写类的成员变量
3. 编写类的成员方法

```java
public class 类名 {
    //成员变量
    变量1的数据类型 变量1;
    变量2的数据类型 变量2;
    ...
    //成员方法
    方法1;
    方法2;
    ...
}
```

#### 8. 对象的使用

创建对象

- 格式：`类名 对象名 = new 类名();`

使用对象

1. **使用成员变量**
   - 格式：`对象名.变量名`
2. **使用成员方法**
   - 格式：`对象名.方法名()`

### 2. 成员变量和局部变量

#### 1. 什么是成员变量和局部变量

成员变量：类中方法外的变量

局部变量：方法中的变量

#### 2. 成员变量和局部变量区别

| 区别           | 成员变量                                   | 局部变量                                       |
| -------------- | ------------------------------------------ | ---------------------------------------------- |
| 类中位置不同   | 类中方法外                                 | 方法内或者方法声明上                           |
| 内存中位置不同 | 堆内存                                     | 栈内存                                         |
| 生命周期不同   | 随着对象的存在而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的调用完毕而消失 |
| 初始化值不同   | 有默认的初始化值                           | 没有默认的初始化值，必须先定义，赋值，才能使用 |

### 3. 封装

#### 1. private 关键字

- 是一个权限修饰符
- 可以修饰成员（成员变量和成员方法）
- 作用是保护成员不被别的类使用，被 `private` 修饰的成员只在本类中才能访问

针对 `private` 修饰的成员变量，如果需要被其他类使用，提供相应的操作

- 提供“ `get 变量名()`”方法，用于获取成员变量的值，方法用 `public` 修饰
- 提供“ `set 变量名(参数)`”方法，用于设置成员变量的值，方法用 `public` 修饰

#### 2. private 关键字的使用

一个标准类的编写：

- 把成员变量用 `private` 修饰
- 提供对应的 `getXxx()/setXxx()` 方法

#### 3. this 关键字

1. this 修饰的变量用于指代成员变量
   - 方法的形参如果与成员变量同名，不带 this 修饰的变量指的是形参，而不是成员变量
   - 方法的形参没有与成员变量同名，不带 this 修饰的变量指的是成员变量
2. 什么时候使用 this 呢？**解决局部变量隐藏成员变量**
3. this：代表所在类的对象引用
   - 记住：方法被哪个对象调用，this 就代表哪个对象

#### 5. 封装

##### **1. 封装概述**

是面向对象三大特征之一（**封装，继承，多态**）
是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的

##### **2. 封装原则**

将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量 `private`，提供对应的 `getXxx()/setXxx()` 方法

##### **3. 封装好处**

通过方法来控制成员变量的操作，提高了代码的安全性

把代码用方法进行封装，提高了代码的复用性

### 4. 构造方法

#### 1. 构造方法概述

构造方法是一种特殊的方法

作用：创建对象

格式：

```java
public class 类名 {
    修饰符 类名 (参数) {
    }
}
```

功能：主要是完成对象数据的初始化

#### 2. 构造方法的注意事项

1. 构造方法的创建

   - 如果没有定义构造方法，系统将给出一个**默认**的**无参数构造方法**
   - 如果定义了构造方法，系统将不再提供默认的构造方法

2. 构造方法的重载

   - 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法

3. 推荐的使用方式

- **无论是否使用，都手工书写无参数构造方法**

#### 3. 标准类的制作

1. 成员变量
   - 使用 `private` 修饰
2. 构造方法
   - 提供一个无参构造方法
   - 提供一个带多个参数的构造方法
3. 成员方法
   - 提供每一个成员变量对应的 `setXxx()/getXxx()`
   - 提供一个显示对象信息的 `show()`
4. 创建对象并为其成员变量赋值的两种方式
   - 无参构造方法创建对象后使用 `setXxx()` 赋值
   - 使用带参构造方法直接创建带有属性值的对象

## 13. String

### 1. API

#### 1. API 概述

**API**(**A**pplication **P**rogramming **I**nterface)：应用程序编程接口

Java API：指的就是 JDK 中提供的各种功能的 Java 类

#### 2. 如何使用帮助文档

1. 右键打开该文档
2. 找到索引选项卡中的输入框
3. 在输入框中输入 Random
4. 看在哪个包下
5. 看类的描述
6. 看构造方法
7. 看成员方法

#### 3. API 使用练习

::: warning 注意

**调用方法的时候，如果方法有明确的返回值，我们用变量接收**

**可以手动完成，也可以使用快捷键的方式完成(Ctrl + Alt + V)**

:::

### 2. String

#### 1. String 概述

String 类在 `java.lang` 包下，所以使用的时候不需要导包

`String` 类代表**字符串**，Java 程序中的所有字符串文字（例如 "abc"）

也就是说，**Java 程序中所有的双引号字符串，都是 String 类的对象**

字符串的特点

- 字符串不可变，它们的值在创建后不能被更改
- 虽然 String 的值是不可变的，但它们可以被共享
- 字符串效果上相当于字符数组（`char[]`），但是底层原理是字节数组（`byte[]`）

::: tip

**JDK 8 及以前是字符数组，JDK 9 及以后是字节数组**

:::

#### 2. String 构造方法

| 方法名                       | 说明                                       |
| ---------------------------- | ------------------------------------------ |
| `public String ()`           | 创建一个空白字符串对象，不含有任何内容     |
| `public String (char[] chs)` | 根据字符数组的内容，来创建字符串对象       |
| `public String (byte[] bys)` | 根据字节数组的内容，来创建字符串对象       |
| `String s = "abc";`          | 直接赋值的方式创建字符串对象，内容就是 abc |

#### 3. String 对象的特点

1. 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

   ```java
   char[] chs = {'a', 'b', 'c'};
   String s1 = new String(chs);
   String s2 = new String(chs);
   ```

   上面的代码中，JVM 会首先创建一个字符数组，然后每一次 new 的时候都会有一个新的地址，只不过 s1 和 s2 参考的字符串内容是相同的

2. 以""方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都会只建立一个 String 对象，并在字符串池中维护

   ```java
   String s3 = "abc";
   String s4 = "abc";
   ```

   在上面的代码中，针对第一行代码，JVM 会建立一个 String 对象放在字符串池中，并给 s3 参考;

   第二行则让 s4 直接参考字符串池中的 String 对象，也就是说它们本质上是同一个对象

#### 4. 字符串的比较

使用`==`做比较

- 基本类型：比较的是**数据值**是否相同
- 引用类型：比较的是**地址值**是否相同

字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫：`equals()`

- `public boolean equals (Object anObject)`：将此字符串与指定对象进行比较。由于我们比较的是字符串对象，所以参数直接传递一个字符串

#### 5. 通过帮助文档查看 String 中的方法

| 方法名                                    | 说明                                             |
| ----------------------------------------- | ------------------------------------------------ |
| `public boolean equals (Object anObject)` | 比较字符串的内容，严格区分大小写（用户名和密码） |
| `public char charAt (int index)`          | 返回指定索引处的 char 值                         |
| `public int length()`                     | 返回此字符串的长度                               |

### 3. StringBuilder

#### 1. StringBuilder 概述

StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器

这里的可变指的是 StringBuilder 对象中的内容是可变的

**`String` 和 `StringBuilder` 的区别**

- String：内容是不可变的
- StringBuilder：内容是可变的

#### 2. StringBuilder 构造方法

| 方法名                             | 说明                                       |
| ---------------------------------- | ------------------------------------------ |
| `public StringBuilder()`           | 创建一个空白可变字符串对象，不含有任何内容 |
| `public StringBuilder(String str)` | 根据字符串的内容，来创建可变字符串对象     |

#### 3. StringBuilder 的添加和反转方法

| 方法名                                   | 说明                     |
| ---------------------------------------- | ------------------------ |
| `public StringBuilder append (任意类型)` | 添加数据，并返回对象本身 |
| `public StringBuilder reverse ()`        | 返回相反的字符序列       |

#### 4. StringBuilder 和 String 相互转换

1. StringBuilder 转换为 String

   `public String toString()`：通过 toString()就可以实现把 StringBuilder 转换为 String

2. String 转换为 StringBuilder

   `public StringBuilder(String s)`：通过构造方法就可以实现把 String 转换为 StringBuilder

#### 5. 通过帮助文档查看 StringBuilder 中的方法

| 方法名                                   | 说明                                                     |
| ---------------------------------------- | -------------------------------------------------------- |
| `public StringBuilder append (任意类型)` | 添加数据，并返回对象本身                                 |
| `public StringBuilder reverse ()`        | 返回相反的字符序列                                       |
| `public String toString()`               | 通过 toString() 就可以实现把 StringBuilder 转换为 String |

## 14. 集合基础

### 1. 集合概述

编程的时候如果要存储多个数据，使用长度固定的数组存储格式，不一定满足我们的需求，更适应不了变化的需求，那么此时该如何选择呢？

集合的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变

集合类有很多，目前我们先学习一个：`ArrayList`

`ArrayList<E>`：

- 可调整大小的数组实现
- \<E\> 是一种特殊的数据类型，泛型。

**怎么用呢？**

再出现 E 的地方我们使用引用数据类型替换即可

举例：

- `ArrayList<String>`
- `ArrayList<Student>`

### 2. ArrayList 构造方法和添加方法

| 方法名                                   | 说明                           |
| ---------------------------------------- | ------------------------------ |
| `public ArrayList()`                     | 创建一个空的集合对象           |
| `public boolean add (E e)`               | 将指定的元素追加到此集合的末尾 |
| `public void add (int index, E element)` | 在此集合中的位置插入指定的元素 |

### 3. ArrayList 集合常用方法

| 方法名                                | 说明                                   |
| ------------------------------------- | -------------------------------------- |
| `public boolean remove (Object o)`    | 删除指定的元素，返回删除是否成功       |
| `public E remove (int index)`         | 删除指定索引处的元素，返回被删除的元素 |
| `public E set (int index, E element)` | 修改指定索引处的元素，返回被修改的元素 |
| `public E get (int index)`            | 返回指定索引处的元素                   |
| `public int size ()`                  | 返回集合中的元素个数                   |

## 15. 继承

### 1. 继承概述

继承格式

- 格式：`public class 子类名 extends 父类名 { }`
- 范例：`public class Zi extends Fu { }`
- Fu：是父类，也被称为基类、超类
- Zi：是子类，也被称为派生类

继承中子类的特点：

- 子类可以有父类的内容
- 子类还可以有自己特有的内容

### 2. 继承的好处和弊端

继承的好处

- 提高了代码的**复用性**（多个类相同的成员可以放到同一个类中）
- 提高了代码的**维护性**（如果方法的代码需要修改，修改一处即可）

继承的弊端

- 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性

什么时候使用继承？

- 继承体现的关系：**is a**
- 假设法：我有两个类 A 和 B，如果他们满足 A 是 B 的一种，或者 B 是 A 的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不能滥用继承
- 举例：苹果和水果，猫和动物，猫和狗

### 3. 继承中变量的访问特点

在子类中访问一个变量

- 子类局部范围查找
- 子类成员范围查找
- 父类成员范围查找
- 如果都没有就报错（不考虑父亲的父亲...）

### 4. super

`super` 关键字的用法和 `this` 关键字的用法相似

- `this`：代表本类对象的引用
- `super`：代表父类存储空间的标识（可以理解为父亲对象引用）

::: tip

this 关键字指向调用该方法的对象

一般我们是在当前类中使用 this 关键字，所以我们常说 this 代表本类对象的引用

:::

| 关键字  | 访问成员变量                      | 访问构造方法                  | 访问成员方法                           |
| ------- | --------------------------------- | ----------------------------- | -------------------------------------- |
| `this`  | `this.成员变量` 访问本类成员变量  | `this(...)` 访问本类构造方法  | `this.成员方法(...)` 访问本类成员方法  |
| `super` | `super.成员变量` 访问父类成员变量 | `super(...)` 访问父类构造方法 | `super.成员方法(...)` 访问父类成员方法 |

### 5. 继承中构造方法的访问特点

子类中所有的构造方法默认都会访问父类中无参的构造方法为什么呢?

- 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化
- 每一个子类构造方法的第一条语句默认都是：`super()`

如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢?

- 通过使用 super 关键字去显示的调用父类的带参构造方法

**推荐：自己给出无参构造方法**

### 6. 继承中成员方法的访问特点

通过子类对象访问一个方法

- 子类成员范围找
- 父类成员范围找
- 如果都没有就报错（不考虑父亲的父亲...）

### 7. 方法重写

方法重写概述

- 子类中出现了和父类中一模一样的方法声明

方法重写的应用

- 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容
- 练习：手机类和新手机类

`@Override`

- 是一个注解（注解后面会学习）
- 可以帮助我们检查重写方法的方法声明的正确性

### 8. 方法重写的注意事项

- 私有方法不能被重写（父类私有成员子类是不能继承的）子类方法访问
- 权限不能更低（public > 默认 > 私有）

### 9. Java 中继承的注意事项

- Java 中只支持单继承，不支持多继承
- Java 中类支持多层继承

## 16. 修饰符

### 1. 包

#### 1. 包的概述和使用

其实就是文件夹

作用：对类进行分类管理

包的定义格式

- 格式：`package 包名;` （多级包用的）

带包的 Java 类编译和执行

- 手动建包：

  按照以前的格式编译 Java 文件

  手动创建包

  把 class 文件放到包的最里面

  带包执行

- 自动建包：`java -d HelloWorld.java`

### 2. 导包

使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了

为了简化导包的操作，Java 就提供了导包的功能

导包的格式

- 格式：`import 包名;`

### 3. 修饰符

#### 1. 修饰符的分类

- 权限修饰符
- 状态修饰符

#### 2. 权限修饰符

|   修饰符    | 同一个类中 | 同一个包中子类无关类 | 不同包的子类 | 不同包的无关类 |
| :---------: | :--------: | :------------------: | :----------: | :------------: |
|  `private`  |     ✔      |                      |              |                |
|    默认     |     ✔      |          ✔           |              |                |
| `protected` |     ✔      |          ✔           |      ✔       |                |
|  `public`   |     ✔      |          ✔           |      ✔       |       ✔        |

#### 3. 状态修饰符

- `final`（最终态）
- `static`（静态）

#### 4. final

`final` 关键字是最终的意思，可以修饰成员方法，成员变量，类

`final` 修饰的特点

- 修饰方法：表明该方法是最终方法，**不能被重写**
- 修饰变量：表明该变量是常量，**不能再次被赋值**
- 修饰类：表明该类是最终类，**不能被继承**

#### 5. final 修饰局部变量

变量是基本类型：final 修饰指的是基本类型的**数据值**不能发生改变

变量是引用类型：final 修饰指的是引用类型的**地址值**不能发生改变，但是地址里面的内容是可以发生改变的

#### 6. static

`static` 关键字是静态的意思，可以修饰成员方法，成员变量

`static` 修饰的特点

- 被类的所有对象共享

  这也是我们判断是否使用静态关键字的条件

- 可以通过类名调用

  当然也可以通过对象名调用

  **推荐使用类名调用**

#### 7. static 访问特点

非静态的成员方法

- 能访问静态的成员变量
- 能访问非静态的成员变量
- 能访问静态的成员方法
- 能访问非静态的成员方法

静态的成员方法

- 能访问静态的成员变量
- 能访问静态的成员方法

**总结成一句话就是：静态成员方法只能访问静态成员**

## 17. 多态

### 1. 多态概述

同一个对象，在不同时刻表现出来的不同形态

<br>

举例：猫

我们可以说猫是猫：`猫 cat = new 猫();`

我们也可以说猫是动物：`动物 animal = new 猫();`

这里猫在不同的时刻表现出了不同的形态，这就是多态

<br>

多态的前提和体现

- 有继承/实现关系
- 有方法重写
- 有父类引用指向子类对象

### 2. 多态中成员访问的特点

- **成员变量**：编译看左边，指向看左边
- **成员方法**：编译看左边，执行看右边

<br>

为什么成员变量和成员方法的访问不一样呢？

- 因为成员方法有重写，而成员变量没有

### 3. 多态的好处和弊端

- 多态的好处：提高了程序的扩展性

  具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作

- 多态的弊端：不能使用子类的特有功能

### 4. 多态中的转型

- 向上转型

  从子到父

  父类引用指向子类对象

- 向下转型

  从父到子

  父类引用转为子类对象

## 18. 抽象类

### 1. 抽象类描述

在 Java 中，一个**没有方法体**的方法应该定义为**抽象方法**，而类中如果有**抽象方法**，该类必须定义为**抽象类**

### 2. 抽象类的特点

- 抽象类和抽象方法必须使用 `abstract` 关键字修饰

  `public abstract class 类名{}`

  `public abstract void eat ();`

- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类

- 抽象类不能实例化

  抽象类如何实例化呢？通过子类对象实例化，这也叫抽象类多态

- 抽象类的子类

  要么重写抽象类中的所有抽象方法

  要么是抽象类

### 3. 抽象类的成员特点

- 成员变量

  可以是变量

  也可以是常量

- 构造方法

  有构造方法，但是不能实例化

  那么，构造方法的作用是什么呢？用于子类访问父类数据的初始化

- 成员方法

  可以有抽象方法：限定子类必须完成某些动作

  也可以有非抽象方法：提高代码复用性

## 19. 接口

### 1. 接口概述

接口是一种**公共的规范标准**，只要符合规范标准，大家都可以通用

Java 中的接口更多的体现在**对行为的抽象**

### 2. 接口的特点

- 接口用关键字 `interface` 修饰

  `public interface 接口名 {}`

- 实现接口用 `implements` 表示

  `public class 类名 implements 接口名 {}`

- 接口不能实例化

  接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。

- 接口的实现类

  要么重写接口中的所有抽象方法

  要么是抽象类

### 3. 接口的成员特点

- 成员变量

  只能是常量

  默认修饰符：`public static final`

- 构造方法

  接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在

  一个类如果没有父类，默认继承自 Object 类

- 成员方法

  只能是抽象方法

  默认修饰符：`public abstract`

### 4. 类和接口的关系

- 类和类的关系

  继承关系，只能单继承，但是可以多层继承

- 类和接口的关系

  实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

- 接口和接口的关系

  继承关系，可以单继承，也可以多继承

### 5. 抽象类和接口的区别

- 成员区别

  抽象类：变量，常量；有构造方法，也有非抽象方法

  接口：常量；抽象方法

- 关系区别

  类与类：继承，单继承

  类与接口：实现，可以单实现，也可以多实现

  接口与接口：继承，单继承，多继承

- 设计概念区别

  抽象类：对象抽象，包括属性、行为

  接口：对行为抽象，主要是行为

门和警报的例子

门：都有 `open()` 和 `close()` 两个动作，这个时候，我们可以分别使用抽象类和接口来定义这个抽象概念

```java
//抽象类
public abstract class Door {
    public abstract void open();
    public abstract void close();
}
```

```java
//接口
public interface Door {
    void open();
    void close();
}
```

```java
//抽象类
public abstract class Door {
    public abstract void open();
    public abstract void close();
    public abstract void alarm();
}
```

```java
//接口
public interface Door {
    void open();
    void close();
    void alarm();
}
```

```java
public interface Alarm {
    void alarm();
}
public abstract class Door {
    public abstract void open();
    public abstract void close();
}
public class AlarmDoor extends Door implements Alarm {
    public void open() {
        // ...
    }
    public void close() {
        // ...
    }
    public void alarm() {
        // ...
    }
}
```

在这里，我们再次强调抽象类是对事物的抽象，而接口是对行为的抽象

## 20. 形参和返回值

### 1. 类名作为形参和返回值

- 方法的形参是类名，其实需要的是该类的对象
- 方法的返回值是类名，其实返回的是该类的对象

### 2. 抽象类名作为形参和返回值

- 方法的形参是抽象类名，其实需要的是该抽象类的子类对象
- 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象

### 3.接口名作为形参和返回值

- 方法的形参是接口名，其实需要的是该接口的实现类对象
- 方法的返回值是接口名，其实返回的是该接口的实现类对象

## 21. 内部类

### 1. 内部类概述

内部类：就是一个类中定义一个类。举例：在一个类 A 的内部定义一个类 B，类 B 就被称为内部类

内部类的定义格式：

- 格式：

```java
public class 类名 {
    修饰符 class 类名 {
    }
}
```

- 范例：

```java
public class Outer {
    修饰符 class Inner {
    }
}
```

内部类的访问特点

- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须包括创建对象

### 2. 成员内部类

按照内部类在类中定义的位置不同，可以分为如下两种形式

- 在类的成员位置：成员内部类
- 在类的局部位置：局部内部类

成员内部类，外界如何创建对象使用呢？

- 格式：外部类名.对象名 对象名 = 外部类对象.内部类对象

### 3. 局部内部类

局部内部类是在方法中定义的类，所有外界是无法直接使用，需要在方法内部创建对象并使用

该类可以直接访问外部类的成员，也可以访问方法内部的局部变量

### 4. 匿名内部类

前提：存在一个类或者接口，这里的类可以是具体类也可以是抽象类

- 格式：

```java
new 类名或者接口名() {
    重写方法;
}
```

### 5. 匿名内部类在开发中的使用

```java
/*
 跳高接口
*/
public interface Jumpping {
    void jump();
}
```

```java
/*
 接口操作类，里面有一个方法，方法的参数是接口名
*/
public class JumppingOperator {
    public void method (Jumpping j) {
        j.jump();
    }
}
```

```java
/*
 测试类
*/
public class JumppingDemo {
    public static void main(String[] args) {
        // 需求：创建接口操作类的对象，调用 method 方法
    }
}
```

## 22. 常用 API

### 1. Math

#### 1. Math 类概述

Math 包含执行基本数字运算的方法

<br>

**没有构造方法，如何使用类中的成员呢？**

看类的成员是否都是静态的，如果是，通过类名就可以直接调用

#### 2. Math 类的常用方法

| 方法名                                       | 说明                                             |
| -------------------------------------------- | ------------------------------------------------ |
| public static int abs(int a)                 | 返回参数的绝对值                                 |
| public static double ceil(double a)          | 返回大于或等于参数的最小 double 值，等于一个整数 |
| public static double floor(double a)         | 返回大于或等于参数的最大 double 值，等于一个整数 |
| public static double round(float a)          | 按照四舍五入返回最接近参数的 int                 |
| public static double max(int a, int b)       | 返回两个 int 值中的较大值                        |
| public static double min(int a, int b)       | 返回两个 int 值中的较小值                        |
| public static double pow(double a, double b) | 返回 a 的 b 次幂的值                             |
| public static double random()                | 返回值为 double 的正值，[0.0, 1.0)               |

### 2. System

#### 1. System 类概述

System 包含几个有用的类字段和方法，它不能被实例化

#### 2. System 类的常用方法

| 方法名                                 | 说明                                         |
| -------------------------------------- | -------------------------------------------- |
| public static void exit(int status)    | 终止当前运行的 Java 虚拟机，非零表示异常终止 |
| public static long currentTimeMillis() | 返回当前时间（以毫秒为单位）                 |

### 3. Object

#### 1. Object 类的概述

Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类

构造方法：public Object()

回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法？

因为它们的顶级父类只有无参构造方法

#### 2. Object 类的常用方法

| 方法名                              | 说明                                                       |
| ----------------------------------- | ---------------------------------------------------------- |
| public String toString()            | 返回对象的字符串表示形式。建议所有子类重写该方法，自动生成 |
| public boolean toString(Object obj) | 比较对象是否相等。默认比较地址，重写可以比较内容，自动生成 |

### 4. Arrays

#### 1. 冒泡排序

排序：将一组数据按照固定的规则进行排列

冒泡排序：一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序

- 如果有 n 个数据进行排序，总共需要比较 n-1 次
- 每一次比较完毕，下一次的比较就会少一个数据参与

#### 2. Arrays 类的概述和常用方法

Arrays 类包含用于操作数组的各种方法

| 方法名                                 | 说明                               |
| -------------------------------------- | ---------------------------------- |
| public static String toString(int[] a) | 返回指定数组的内容的字符串表示形式 |
| public static void sort(int[] a)       | 按照数字顺序排列指定的数组         |

工具类的设计思想：

- 构造方法用 private 修饰
- 成员使用 public static 修饰

### 5. 基本类型包装类

#### 1. 基本类型包装类概述

将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据

常用的操作之一：用于基本数据类型与字符串之间的转换

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| char         | Character |
| boolean      | Boolean   |

#### 2. Integer 类的概述和使用

Integer：包装一个对象中的原始类型 int 的值

| 方法名                                  | 说明                                        |
| --------------------------------------- | ------------------------------------------- |
| public Integer(int value)               | 根据 int 值创建 Integer 对象（**过时**）    |
| public Integer(String s)                | 根据 String 值创建 Integer 对象（**过时**） |
| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer 实例        |
| public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String    |

#### 3. int 和 String 的相互转换

基本类型包装类的最常见操作就是：用于基本类型和字符串之间的相互转换

##### 1. int 转换为 String

public static String `valueOf(int i)`：返回 int 参数的字符串表示形式。该方法是 String 类中的方法

##### 2. String 转换为 int

public static `parseInt(String s)`：将字符串解析为 int 类型。该方法是 Integer 类中的方法

#### 4. 自动装箱和拆箱

- 装箱：把基本数据类型转换为对应的包装类型
- 拆箱：把包装类型转换为对应的基本数据类型

```java
Integer i = 200; // 自动装箱
i += 200; // i = i + 200; i + 200 自动拆箱; i = i + 200; 是自动装箱
```

::: warning 注意

在使用包装类型的时候，如果做操作，最好先判断是否为 null

我们推荐的是，**只要是对象，在使用前就必须进行不为 null 的判断**

:::

### 6. 日期类

#### 1. Date 类概述和构造方法

Date 代表了一个特定的时间，精确到毫秒

| 方法名                 | 说明                                                               |
| ---------------------- | ------------------------------------------------------------------ |
| public Date()          | 分配一个 Date 对象，并初始化，以便它代表它被分配的时间，精确到毫秒 |
| public Date(long date) | 分配一个 Date 对象，并将其初始化为表示从标准基准时间起指定的毫秒数 |

#### 2. Date 类的常用方法

| 方法名                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| public long getTime()          | 获取的是日期对象从 1970 年 1 月 1 日 00:00:00 到现在的毫秒值 |
| public void setTime(long time) | 设置时间，给的是毫秒值                                       |

#### 3. SimpleDateFormat 类概述

SimpleDateFormat 是一个具体的类，用于区域设置敏感的方式格式化和解析时间。我们重点学习**日期格式化和解析**

日期和时间个还是是由日期和时间模式字符串指定，在日期和时间模式字符串中，从 'A' 到 'Z' 以及从 'a' 到 'z' 引号的字母被解释为表示日期或时间字符串的组件的模式字母

常用的模式字母及对应关系如下：

| 字母 | 模式 |
| ---- | ---- |
| y    | 年   |
| M    | 月   |
| d    | 日   |
| H    | 时   |
| m    | 分   |
| s    | 秒   |

#### 4. SimpleDateFormat 的构造方法

| 方法名                                  | 说明                                                     |
| --------------------------------------- | -------------------------------------------------------- |
| public SimpleDateFormat()               | 构造一个 SimpleDateFormat，使用默认模式和日期格式        |
| public SimpleDateFormat(String pattern) | 构造一个 SimpleDateFormat 使用给定的模式和默认的日期格式 |

#### 5. Calendar 类概述

Calendar 为某一时刻和一组日历之间的转换提供了一些方法，并为操作日历字段提供了一些方法

Calendar 提供了一个类方法 getInstance 用于获取 Calendar 对象，其日历字段已使用当前日期和时间初始化：

Calendar rightNow = Calendar.getInstance();

#### 6. calendar 的常用方法

| 方法名                                      | 说明                                                   |
| ------------------------------------------- | ------------------------------------------------------ |
| public int get(int field)                   | 返回给定日历字段的值                                   |
| public abstract void(int field, int amount) | 根据日历的规则，将指定的时间量添加或减去给定的日历字段 |
| public final void set(int year, int date)   | 设置当前日历的年月日                                   |

## 23. 异常

### 1. 异常概述

异常：就是程序出现了不正常的情况

#### 异常体系

Throwable

- Error
- Exception
  - RuntimeException
  - 非 RuntimeException

Error：严重问题，不需要处理

Exception：称为异常类，它表示程序本身可以处理的问题

- RuntimeException：在编译期是不检查的，出现问题后，需要我们回来修改代码
- 非 RuntimeException：编译器就必须处理的，否则程序不能通过编译，就更不能正常运行了

### 2. JVM 的默认处理方案

如果程序出现了问题，我们没有做任何处理，最终 JVM 会做出默认的处理

- 把异常的名称，异常原因及异常出现的位置等信息输出在了控制台
- 程序停止运行

### 3. 异常处理

如果程序出现了问题，我们需要自己来处理，有两种方案：

- try ... catch ...
- throws

### 4. 异常处理之 try ... catch

格式：

```java
try {
    可能出现异常的代码;
} catch(异常类名 变量名) {
    异常的处理代码;
}
```

执行流程：

程序从 try 里面的代码开始执行

出现异常，会自动生成一个异常类对象，该异常对象将被提交给 Java 运行时系统

当 Java 运行时系统接收到异常对象时，回到 catch 中去找匹配的异常类，找到后进行异常的处理

执行完毕之后，程序还可以继续往下执行

### 5. Throwable 的成员方法

| 方法名                         | 说明                              |
| ------------------------------ | --------------------------------- |
| public String getMessage()     | 返回此 throwable 的详细消息字符串 |
| public String toString()       | 返回此可抛出的简短描述            |
| public void printStackTrance() | 把异常的错误信息输出在控制台      |

### 6. 编译时异常和运行时异常的区别

Java 中的异常被分为两大类：**编译时异常**和**运行时异常**，也被称为**受检异常**和**非受检异常**

所有的 RuntimeException 类及其子类被称为运行时异常，其他的异常都是编译时异常

- 编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译
- 运行时异常：无需显示处理，也可以和编译时异常一样处理

### 7. 异常处理之 throws

虽然我们通过 try ... catch ... 可以对异常进行处理，但是并不是所有的情况都有权限进行异常的处理

也就是说，有些时候可能出现的异常是我们处理不了的，这个时候该怎么办呢？

针对这种情况，Java 提供了 throws 的处理方案

格式：

```java
throws 异常类名;
```

::: warning 注意

这个格式是跟在方法的括号后面的

:::

- **编译时异常必须要进行处理**，两种处理方案：try ... catch 或者 throws，如果采用 throws 这种方案，将来谁调用谁处理
- **运行时异常可以不处理**，出现问题后，需要我们回来修改代码

### 8. 自定义异常

格式：

```java
public class 异常类名 extends Exception {
    // 无参构造
    // 带参构造
}
```

### 9. throws 和 throw 的区别

#### throws

- 用在方法声明后面，跟的是异常类名
- 表示抛出异常，由该方法的调用者来处理
- 表示出现异常的一种可能性，并不一定会发生这些异常

#### throw

- 用在方法体内，跟的是异常对象名
- 表示抛出异常，由方法体内部的语句处理
- 执行 throw 一定抛出了某种异常

## 24. 集合进阶

### 1. Collection

#### 1. 集合知识回顾

集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变

#### 2. 集合体系结构

- Collection（单列）
  - List（可重复）
    - ArrayList
    - LinkedList
    - ......
  - Set（不可重复）
    - HashSet
    - TreeSet
    - ......
- Map（双列）
  - HashMap
  - ......

接口

实现类

#### 3. Collection 结合概述和使用

Collection 集合概述

- 是单例集合的顶层接口，它表示一组对象，这些对象也称为 Collection 的元素
- JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如 Set 和 List）实现

创建 Collection 集合的对象

- 多态的方式
- 具体的实现类 ArrayList

#### 4. Collection 集合常用方法

| 方法名                     | 说明                               |
| -------------------------- | ---------------------------------- |
| boolean add(E e)           | 添加元素                           |
| boolean remove(Object o)   | 从集合中移除指定的元素             |
| void clear()               | 清空集合中的元素                   |
| boolean contains(Object o) | 判断集合中是否出现指定的元素       |
| boolean isEmpty()          | 判断集合是否为空                   |
| int size()                 | 集合的长度，也就是集合中元素的个数 |

#### 5. Collection 集合的遍历

Iterator：迭代器，集合的专用遍历方式

- Iterator \<E\> iterator()：返回此集合中元素的迭代器，通过集合的 iterator() 方法得到
- 迭代器是通过集合的 iterator() 方法得到的，所以说它是依赖于集合而存在的

Iterator 中的常用方法

- E next()：返回迭代中的下一个元素
- boolean hasNext()：如果迭代具有更多元素，则返回 true

### 2. List

#### 1. List 集合概述和特点

List 集合概述

- 有序集合（也称为序列），用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素
- 与 Set 集合不同，列表通常允许重复的元素

List 集合特点

- 有序：存储和取出的元素顺序一致
- 可重复：存储的元素可以重复

#### 2. List 集合特有方法

| 方法名                        | 说明                                   |
| ----------------------------- | -------------------------------------- |
| void ad(int index, E element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int index)           | 删除指定索引处的元素，返回删除的元素   |
| E set(int index, E element)   | 修改指定索引处的元素，返回被修改的元素 |
| E get(int index)              | 返回指定索引处的元素                   |

#### 3. 并发修改异常

并发修改异常

- ConcurrentModificationException

产生原因

- 迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中预期修改值和实际修改值不一致

解决方案

- 用 for 循环遍历，然后用集合对象做对应的操作即可

#### 4. ListIterator

ListIterator：列表迭代器

- 通过 List 集合的 listIterator() 方法得到，所以说它是 List 集合特有的迭代器
- 用于允许程序员沿任何一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置

ListIterator 中的常用方法

- E next()：返回迭代中的下一个元素
- boolean hasNext()：如果迭代具有更多元素，则返回 true
- E previous()：返回列表中的上一个元素
- boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回 true
- void add(E e)：将指定的元素插入列表

#### 5. 增强 for 循环

增强 for：简化数组和 Collection 集合的遍历

- 实现 Iterator 接口的类允许其对象称为增强型 for 语句的目标
- 它是 JDK5 之后出现的，其内部原理是一个 Iterator 迭代器

增强 for 的格式

- 格式：

```java
for(元素数据类型 遍历名 : 数组或者 Collection 集合) {
    // 在此处使用变量即可，该变量就是元素
}
```

#### 6. 数据结构

数据结构是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合

通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率

#### 7. 常见的数据结构之栈

数据进入栈模型的过程称为：**压/进栈**

数据离开栈模型的过程称为：**弹/出栈**

栈是一种数据**先进后出**的模型

#### 8. 常见数据结构之队列

数据从**后端**进入队列模型的过程称为：**入队列**

数据从**前端**离开队列模型的过程称为：**出队列**

队列是一种数据**先进先出**的模型

#### 9. 常见数据结构之数组

查询数据通过索引定位，查询任意数据耗时相同，**查询效率高**

删除数据时，要将原始数据删除，同时后面每个数据前移，**删除效率低**

添加数据时，添加位置后的每个数据后移，再添加元素，**添加效率极低**

#### 10. 常见数据结构之链表

链表是一种**增删快**的模型（对比数组）

链表是一种**查询慢**的模型（对比数组）

#### 11. List 集合子类特点

List 集合常用子类：ArrayList，LinkedList

- ArrayList：底层数据结构是数组，查询快，增删慢
- LinkedList：底层数据结构是链表，查询慢，增删快

#### 12. LinkedList 集合的特有功能

| 方法名                    | 说明                             |
| ------------------------- | -------------------------------- |
| public void addFirst(E e) | 在该列表开头插入指定的元素       |
| public void addLast(E e)  | 将指定的元素追加到此列表的末尾   |
| public E getFirst()       | 返回此列表中的第一个元素         |
| public E getLast()        | 返回此列表中的最后一个元素       |
| public E removeFirst()    | 从此列表中删除并返回第一个元素   |
| public E removeLast()     | 从此列表中删除并返回最后一个元素 |

### 3. Set

#### 1. Set 集合概述和特点

Set 集合特点

- 不包含重复元素的集合
- 没有带索引的方法，所以不能使用普通 for 循环遍历

#### 2. 哈希值

哈希值：是 JDK 根据对象的**地址**或者**字符串**或者**数字**算出来的 int 类型的**数值**

Object 类中有一个方法可以获取**对象的哈希值**

- public int hashCode()：返回对象的哈希码值

对象的哈希值特点

- 同一个对象多次调用 hashCode() 方法返回的哈希值是相同的
- 默认情况下，不同对象的哈希值是不同的。而重写 hashCode 方法，可以实现让不同对象的哈希值相同

#### 3. HashSet 集合概述和特点

HashSet 集合特点

- 底层数据结构是哈希表
- 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致
- 没有带索引的方法，所以不能使用普通 for 循环遍历
- 由于是 Set 集合，所以不包含重复元素的集合

#### 4. HashSet 集合保证元素唯一性源码分析

HashSet 集合添加一个元素的过程：

HashSet 集合存储元素：

- 要保证元素唯一性，需要重写 `hashCode()` 和 `equals()`

#### 5. 常见数据结构之哈希表

哈希表

- JDK8 之前，底层采用**数组 + 链表**实现，可以说是一个元素为链表的数组
- JDK8 之后，在长度比较长的时候，底层实现了优化

#### 6. LinkedHashSet 集合概述和特点

LinkedHashSet 集合特点

- 哈希表和链表实现的 Set 接口，具有可预测的迭代次序
- 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的
- 由哈希表保证元素唯一，也就是说没有重复的元素

#### 7. TreeSet 集合概述和特点

TreeSet 集合特点

- 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法

  TreeSet()：根据其元素的自然排序进行排序

  TreeSet(Comparator comparator)：根据指定的比较器进行排序

- 没有带索引的方法，所以不能使用普通 for 循环循环遍历

- 由于是 Set 集合，所以不包含重复元素的集合

#### 8. 自然排序 Comparable 的使用

- 存储学生对象并遍历，创建 TreeSet 集合使用**无参构造方法**
- 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序

结论

- 用 TreeSet 集合存储自定义对象，无参构造方法使用的是**自然排序**对元素进行排序的
- 自然排序，就是**让元素所属的类实现 Comparable 接口**，重写 compareTo(To) 方法
- 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写

#### 9. 比较器排序 Comparator 的使用

- 存储学生对象并遍历，创建 TreeSet 集合使用**带参构造方法**
- 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序

结论

- 用 TreeSet 集合存储自定义对象，带参构造方法使用的是**比较器排序**对元素进行排序的
- 比较器排序，就是**让集合构造方法接收 Comparator 的实现类对象**，重写 compare(T o1, T o2) 方法
- 重写方法时，一定要注意排序必须按照要求的主要条件和次要条件来写

### 4. 泛型

#### 1. 泛型概述

泛型：是 JDK5 中注入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型

它的本质是**参数化类型**，也就是说所操作的数据类型被指定为一个参数

一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？

顾名思义，就是**将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型**

这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口

泛型定义格式：

- \<类型\>：指定一种类型的格式。这里的类型可以看成是形参
- \<类型 1, 类型 2 ...\>：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参
- 将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型

泛型的好处：

- 把运行时期的问题提前到了编译期间
- 避免了强制类型转换

#### 2. 泛型类

泛型类的定义格式：

- 格式：修饰符 class 类名 \<类型\> { }

  此处 **T** 可以随便写为任意标识，常见的如 **T、E、K、V** 等形式的参数常用于表示泛型

#### 3. 泛型方法

泛型方法的定义格式：

- 格式：修饰符 \<类型\> 返回值类型 方法名(类型 变量名) { }

#### 4. 泛型接口

泛型接口的定义格式：

- 格式：修饰符 interface 接口名 \<类型\> { }

#### 5. 类型通配符

为了表示各种泛型 List 的父类，可以使用类型通配符

- 类型通配符：**\<?\>**
- List<?>：表示元素类型未知的 List，它的元素可以匹配**任何的类型**
- 这种带通配符的 List 仅表示它是各种泛型 List 的父亲，并不能把元素添加到其中

如果说我们不希望 List\<?\> 是任何泛型 List 的父类，只希望它代表某一类泛型 List 的父类，可以使用类型通配符的上限

- 类型通配符上限：**\<? extends 类型\>**
- List\<? extends Number\>：它表示的类型是 **Number 或者其子类型**

除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限

- 类型通配符下限：**\<? super 类型\>**
- List\<? super Number\>：它表示的类型是 **Number 或者其父类型**

#### 6. 可变参数

可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了

- 格式：修饰符 返回值类型 方法名(数据类型 ... 变量名) { }

可变参数注意事项

- 这里的变量其实是一个数组
- 如果一个方法有多个参数，包含可变参数，**可变参数要放在最后**

#### 7. 可变参数的使用

Arrays 工具类中有一个静态方法：

- public static \<T\> List \<T\> asList(T ... a)：返回由指定数组支持的固定大小的列表
- 返回的集合不能做增删操作，可以做修改操作

List 接口中有一个静态方法：

- public static \<E\> List\<E\> of(E ... elements)：返回包含任意数量元素的不可变列表
- 返回的集合不能做增删改操作

Set 接口中有一个静态方法：

- public static \<E\> Set of(E ... elements)：返回一个包含任意数量元素的不可变集合
- 在给元素的时候，不能给重复的元素
- 返回的集合不能做增删操作，没有修改的方法

### 5. Map

#### 1. Map 集合概述和使用

Map 集合概述

- Interface Map \<K, V\> K：键的类型；V：值的类型
- 将键映射到值的对象；不能包含重复的键；每个键可以映射到最多一个值

创建 Map 集合的对象

- 多态的方式
- 具体的实现类 HashMap

#### 2. Map 集合的基本功能

| 方法名                              | 说明                                 |
| ----------------------------------- | ------------------------------------ |
| V put(K key,V value)                | 添加元素                             |
| V remove(Object key)                | 根据键删除键值对元素                 |
| void clear()                        | 移除所有的键值对元素                 |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |
| boolean containsValue(Object value) | 判断集合是否包含指定的值             |
| boolean isEmpty()                   | 判断集合是否为空                     |
| int size()                          | 集合的长度，也就是集合中键值对的个数 |

#### 3. Map 集合的获取功能

| 方法名                                  | 说明                         |
| --------------------------------------- | ---------------------------- |
| V get(Object key)                       | 根据键获取值                 |
| Set\<K\> keySet()                       | 获取所有键的集合             |
| Collection\<V\> values()                | 获取所有值的集合             |
| **Set\<Map.Entry\<K, V\>\> entrySet()** | **获取随意键值对对象的集合** |

#### 4. Map 集合的遍历（方式 1）

我们刚才存储的元素都是成对出现的，所以我们把 Map 看成是一个夫妻对的集合

遍历思路

- 把所有的丈夫给集中起来
- 遍历丈夫的集合，获取到每一个丈夫

转换为 Map 集合中的操作：

- 获取所有键的集合。用 keySet() 方法实现
- 遍历键的集合，获取到每一个键。用增强 for 实现
- 根据键去找值。用 get(Object key) 方法实现

#### 5. Map 集合的遍历（方式 2）

我们刚才存储的元素都是成对出现的，所以我们把 Map 看成是一个夫妻对的集合

遍历思路

- 获取所有结婚证的集合
- 遍历结婚证的集合，得到每一个结婚证
- 根据结婚证获取丈夫和妻子

转换为 Map 集合中的操作：

- 获取所有键值对对象的集合

  **Set \<Map.Entry\<K, V\>\> entrySet()：获取所有键值对的集合**

- 遍历键值对对象的集合，得到每一个键值对对象

  用增强 for 实现，得到每一个 **Map.Entry**

- 根据键值对对象获取键和值

  用 **getKey()** 得到键

  用 **getValue()** 得到值

### 6. Collections

#### 1. Collections 概述和使用

Collections 类的概述

- 是针对集合操作的工具类

Collections 类的常用方法

- public static \<T extends Comparable\<? super T\>\> void sort(List\<T\> list)：将指定的列表按升序排序
- public static void reverse(List\<?\> list)：反转指定列表中元素的顺序
- public static void shuffle(List\<?\> list)：使用默认的随机源随机排列指定的列表

## 25. IO 流

### 1. File

#### 1. File 类概述和构造方法

File：它是文件和目录路径名的抽象表示

- 文件和目录是可以通过 File 封装成对象的

- 对于 File 而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。

  将来是要通过具体的操作把这个路径的内容转换为具体存在的

| 方法名                            | 说明                                                       |
| --------------------------------- | ---------------------------------------------------------- |
| File(String pathname)             | 通过给定的路径名字符串转换为抽象路径名来创建新的 File 实例 |
| File(String parent, String child) | 从父路径名字符串和子路径名字符串创建新的 File 实例         |
| File(File parent, String child)   | 从父抽象路径名和子路径名字符串创建新的 File 实例           |

#### 2. File 类创建功能

| 方法名                         | 说明                                                             |
| ------------------------------ | ---------------------------------------------------------------- |
| public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 |
| public boolean mkdir()         | 创建由此抽象路径名命名的目录                                     |
| public boolean mkdirs()        | 创建由此抽象路径名命名的目录，包括任何必须但不存在的父目录       |

#### 3. File 类判断和获取功能

| 方法名                          | 说明                                                     |
| ------------------------------- | -------------------------------------------------------- |
| public boolean isDirectory()    | 测试此抽象路径名表示的 File 是否为目录                   |
| public boolean isFile()         | 测试此抽象路径名表示的 File 是否为文件                   |
| public boolean exists()         | 测试此抽象路径名表示的 File 是否存在                     |
| public String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串                       |
| public String getPath()         | 返回此抽象路径名转换为路径名字符串                       |
| public String getName()         | 返回此抽象路径名表示的文件或目录的名称                   |
| public String[] List()          | 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组 |
| public File[] listFiles         | 返回此抽象路径名表示的目录中的文件和目录的 File 对象数组 |

#### 4. File 类删除功能

| 方法名                  | 说明                               |
| ----------------------- | ---------------------------------- |
| public boolean delete() | 删除由此抽象路径名表示的文件或目录 |

绝对路径和相对路径的区别

- 相对路径：**完整的路径名**，不需要任何其他信息就可以定位它所表示的文件。
- 相对路径：必须使用取自其他路径名的信息进行解释。

删除目录时的注意事项：

- 如果一个**目录中有内容**（目录，文件），**不能直接删除**。应该先删除目录中的内容，最后才能删除目录

#### 5. 递归

递归概述：以编程的角度来看，递归指的是方法定义中调用方法本身的现象

递归解决问题的思路：

把一个复杂的问题层层转化为一个**与原问题相似的规模较小**的问题来求解

递归策略只需**少量的程序**就可以描述出解题过程所需要的多次重复计算

递归解决问题需要找到两个内容：

- 递归出口：否则会出现内存溢出
- 递归原则：与原问题相似的规模较小的问题

### 2. 字节流

#### 1. IO 流概述和分类

IO 流概述：

- IO：输入/输出（Input？Output）

- 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输

- IO 流就是用来处理设备间数据传输问题的

  常见的应用：文件复制；文件上传；文件下载

IO 流分类：

- 按照数据的流向
  - 输入流：读数据
  - 输出流：写数据
- 按照数据类型来分
  - 字节流
    - 字节输入流；字节输出流
  - 字符流
    - 字符输入流；字符输出流

一般来说，我们说 IO 流的分类是按照**数据类型**来分的

那么这两种流都在什么情况下使用呢？

- 如果数据通过 Windows 自带的记事本打开，我们还可以**读懂里面的内容**，就使用字符流，否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流。

#### 2. 字节流写数据

字节流抽象基类

- InputStream：这个抽象类表示字节输入流的所有类的超类
- OutputStream：这个抽象类表示字节输出流的所有类的超类
- 子类名特点：子类名称都是以其父类名作为子类名的后缀

FileOutputStream：文件输出流用于将数据写入 File

- FIleOutputStream(String name)：创建文件输出流以指定的名称写入文件

使用字节输出流写出数据的步骤：

- 创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）
- 调用字节输出流对象的写数据方法
- 释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）

#### 3. 字节流写数据的 3 种方式

| 方法名                                 | 说明                                                                                           |
| -------------------------------------- | ---------------------------------------------------------------------------------------------- |
| void write(int b)                      | 将指定的字节写入此文件输出流                                                                   |
| void write(byte[] b)                   | 将 b.length 字节从指定的字节数组写入此文件输出流一次写一个字节数组数据                         |
| void write(byte[] b, int off, int len) | 将 len 字节从指定的字节数组开始，从偏移量 off 开始写入此文件输出流一次写一个字节数组的部分数据 |

#### 4. 字节流写数据的两个小问题

字节流写数据如何实现换行呢？

- x 写完数据后，加换行符

  windows：**\r\n**

  linux：**\n**

  mac：**\r**

字节流写数据如何实现追加写入呢？

- public FileOutputStream(String name, boolean append)
- 创建文件输出流以指定的名称写入文件。如果第二个参数为 true，则字节将写入文件的末尾而不是开头

#### 5. 字节流写数据加异常处理

**finally**：在异常处理时提供 finally 块来执行所有清除操作。比如 IO 流中的释放资源

特点：被 finally 控制的语句一定会执行，除非 JVM 退出

```java
try {
    可能出现异常的代码;
} catch(异常类名 变量名) {
    异常的处理代码;
} finally {
    执行所有清除操作;
}
```

#### 6. 字节流读数据（一次读一个字节数组）

需求：把文件 fos.txt 中的内容读取出来在控制台输出

FileInputStream：从文件系统中的我呢间获取输入字节

- FileInputStream(String name)：通过打开实际文件的连接来创建一个 FIleInputStream，该文件由文件系统中的路径名 name 命名

使用字节输入流读取数据的步骤：

1. 创建字节输入流对象
2. 调用字节输入流对象的读数据方法
3. 释放资源

#### 7. 字节缓冲流

字节缓冲流：

- BufferOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用
- BufferedInputStream：创建 BufferedInputStream 将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节

构造方法：

- 字节缓冲输出流：BufferedOutputStream(OutputStream out)
- 字节缓冲输入流：BufferedInputStream(InputStream in)

为什么构造方法需要的是字节流，而不是具体的文件或者路径呢？

- 字节缓冲流**仅仅提供缓冲区**，而真正的读写数据还得依靠基本的字节流对象进行操作

### 3. 字符流

#### 1. 为什么会出现字符流

由于字节流操作中文不是特别的方便，所以 Java 就提供字符流

- **字符流** = **字节流** + **编码表**

用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？

- 汉字在存储的时候，无论选择哪种编码存储第一个字节都是负数

#### 2. 编码表

基础知识：

- 计算机中存储的信息都是用**二进制**数表示的；我们在屏幕上看到的英文、汉字等字符时二进制数转换之后的结果

- 按照某种规则，将字符存储到计算机中，称为**编码**。反之，将存储在计算机中的二进制数按照某种规则解析出来，称为**编码**。这里强调一下：按照 A 编码存储，必须按照 A 编码解析，这样才能显示正确的文本符号。否则就会导致乱码现象

  字符编码：就是一套自然语言的字符与二进制数之间的对应规则（A，65）

字符集：

- 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等

- 计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。

  常见字符集有 ASCII 字符集、GBXXX 字符集、Unicode 字符集等

ASCII 字符集：

- **ASCII**（American Standard Code for Information Interchange，美国信息交换标准代码）：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）
- 基本的 ASCII 字符集，使用 7 位表示一个字符，共 128 字符。ASCII 的扩展字符集使用 8 位表示一个字符，共 256 字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国文字、标点符号、图形符号、数字等

GBXXX 字符集：

- GB2312：简体中文码表。一个小于 127 的字符的意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含 7000 多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名等都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的“全角”字符，而原来在 127 号以下的那些就叫“半角”字符了
- **GBK**：最常用的中文码表。是在 GB2312 标准的基础上的扩展规范，使用了双字节编码方案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时支持繁体字以及日韩汉字等
- GB18030：最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体字以及日韩汉字等

Unicode 字符集：

- 为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。它最多使用 4 个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16 和 UTF32。最为常用的 UTF-8 编码

- **UTF-8** 编码：可以用来表示 Unicode 标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持 UTF-8 编码。它使用一至四字节为每个字符编码

  编码规则：

  128 个 US-ASCII 字符，只需一个字节编码

  拉丁文等字符，需要二个字节编码

  大部分常用字（含中文），使用三个字节编码

  其他极少使用的 Unicode 辅助字符，使用四字节编码

  **小结：采用何种规则编码，就要采用对应规则解码，否则就会出现乱码**

#### 3. 字符串中的编码解码问题

编码：

- byte[] getBytes()：使用平台的默认字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中
- byte[] getBytes(String charsetName)：使用指定的字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中

解码：

- String(byte[] bytes)：通过使用平台的默认字符集解码指定的字节数组来构造新的 String
- String(byte[] bytes, String charsetName)：通过指定的字符集解码指定的字节数组来构造新的 String

#### 4. 字符流中的编码解码问题

字符流抽象基类

- Reader：字符输入流的抽象类
- Writer：字符输出流的抽象类

#### 5. 字符流写数据的 5 种方式

| 方法名                                   | 说明                 |
| ---------------------------------------- | -------------------- |
| void write(int c)                        | 写一个字符           |
| void write(char[] cbuf)                  | 写入一个字符数组     |
| void write(char[] ,int off, int len)     | 写入字符数组的一部分 |
| void write(String str)                   | 写一个字符串         |
| void write(String str, int off, int len) | 写一个字符串的一部分 |

| 方法名  | 说明                                                                 |
| ------- | -------------------------------------------------------------------- |
| flush() | 刷新流，还可以写数据                                                 |
| close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |

#### 6. 字符流读取数据的 2 种方式

| 方法名                | 说明                   |
| --------------------- | ---------------------- |
| int read()            | 一次读一个字符数据     |
| int read(char[] cbuf) | 一次读一个字符数组数据 |

#### 7. 字符缓存流

字符缓存流

- BufferedWriter：将文本写入字符输出流，缓冲字符，可提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途
- BufferedReader：从字符时输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲器大小，或者可以使用默认大小。默认值足够大，可用于大多数用途

构造方法：

- BufferedWriter(Writer out)
- BufferedReader(Reader in)

#### 8. 字符缓冲流特有功能

BufferedWriter：

- void newLine()：写一行行分隔符，行分隔符字符串由系统属性定义

BufferedReader：

- public String readLine()：读一行文字。结果包含的内容的字符串，不包括任何终止字符，如果流的结尾已经到达，则为 null

#### 9. IO 流小结

字节流

- 字节输入流（InputStream）

  - FileInputStream
  - BufferedInputStream

- 字节输出流（OutputStream）
  - FileOutputStream
  - BufferedOutputStream

**小结：字节流可以复制任意文件数据，有 4 种方式一般采用字节缓冲流一次读写一个字节数组的方式**

字符流

- 字符输入流（Reader）
  - InputStreamReader
    - FileReader
  - BufferedReader
- 字符输出流（Writer）
  - OutputStreamWriter
    - FileWriter
  - BufferedWriter

**小结：字符流只能复制文本数据，有 5 种方式，一般采用字符缓存流的特有功能**

#### 10. 复制文件的异常处理

try ... catch ... finally 的做法：

```java
try {
    可能出现异常的代码;
} catch(异常类名 变量名) {
    异常的处理代码;
} finally {
    执行所有清除操作;
}
```

JDK7 改进方案：

```java
try(定义流对象) {
    可能出现异常的代码;
} catch(异常类名 变量名) {
    异常的处理代码;
}

// 自动释放资源
```

JDK9 改进方案

```java
定义输入流对象;
定义输出流对象;
try(输入流对象; 输出流对象) {
    可能出现异常的代码;
} catch(异常类名 变量名) {
    异常的处理代码;
}

// 自动释放资源
```

### 4. 特殊操作

#### 1. 标准输入输出流

System 类中有两个静态的成员变量：

- public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源
- public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标

自己实现键盘录入数据：

- BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

写起来太麻烦，Java 就提供了一个类实现键盘录入

- Scanner sc = new Scanner(System.in);

输出语句的本质：是一个标准的输出流

- PrintStream ps = System.out;
- PrintStream 类有的方法，System.out 都可以使用

#### 2. 打印流

打印流分类：

- 字节打印流：PrintStream
- 字符打印流：PrintWriter

打印流的特点：

- 字只负责输出数据，不负责读取数据
- 有自己的特有方法

字节打印流

- PrintStream(String fileName)：使用指定的文件名创建新的打印流
- 使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出

字符打印流 PrintWriter 的构造方法：

| 方法名                                     | 说明                                                                                                                                   |
| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| PrintWriter(String fileName)               | 使用指定的文件名创建一个新的 PrintWriter，而不需要自动执行刷新                                                                         |
| PrintWriter(Writer out, boolean autoFlush) | 创建一个新的 PrintWriter<br />out：字符输出流<br />autoFlush：一个布尔值，如果为真，则 println，printf，或 format 方法将刷新输出缓冲区 |

#### 3. 对象序列化流

对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象

这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息

字节序列写到文件之后，相当于文件中持久保存了一个对象的信息

反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化

要实现序列化和反序列化就要使用对象序列化和对象反序列化流：

- 对象序列化流：ObjectOutputStream
- 对象反序列化流：ObjectInputStream

对象序列化流：ObjectOutputStream

- 将 Java 对象的原始数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字，则可以在令一个主机或令一个进程中重构对象

构造方法：

- ObjectOutputStream(OutputStream out)：创建一个写入指定的 OutputStream 的 ObjectOutputStream

序列化对象的方法：

- void writeObject(Object obj)：将指定的对象写入 ObjectOutputStream

::: warning 注意

- 一个对象要想被序列化，该对象所属的类必须实现 **Serializable** 接口
- Serializable 是一个**标记接口**，实现该接口，不需要重写任何方法

:::

对象反序列化流：ObjectInputStream

- ObjectInputStream 反序列化先前使用 ObjectOutputStream 编写的原始数据和对象

构造方法：

- ObjectInputStream(InputStream in)：创建从指定的 InputStream 读取的 ObjectInputStream

反序列化对象的方法：

- Object readObject()：从 ObjectInputStream 读取一个对象

用对象序列化流序列化一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出现问题呢？

- 会出问题，抛出 **InvalidClassException** 异常

如果出问题了，如何解决呢？

- 给对象所属的类加一个 serialVersionUID

  private static final long serialVersionUID = 42L;

如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？

- 给该成员变量加 **transient** 关键字修饰，该关键字标记的成员变量不参与序列化过程

#### 4. Properties

Properties 概述：

- 是一个 Map 体系的集合类
- Properties 可以保存到系统或从流中加载

Properties 作为集合的特有方法：

| 方法名                                       | 说明                                                            |
| -------------------------------------------- | --------------------------------------------------------------- |
| Object setProperty(String key, String value) | 设置集合的键和值，都是 String 类型，底层调用 Hashtable 方法 put |
| String getProperty(String key)               | 使用此属性列表中指定的键搜索属性                                |
| Set\<String\> stringPropertyNames()          | 从该属性列表中返回一个不可修改的键集，其中键及对应的值是字符串  |

Properties 和 IO 流结合的方法：

| 方法名                                        | 说明                                                                                                      |
| --------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| void load(InputStream inStream)               | 从输出字节流读取属性列表（键和元素对）                                                                    |
| `void load(Reader reader)`                    | 从输出字符流读取属性列表（键和元素对）                                                                    |
| void store(OutputStream out, String comments) | 将此属性列表（键和元素对）写入此 Properties 表中，以适合于使用 load(InputStream) 方法的格式写入输出字节流 |
| `void store(Writer writer, String comments)`  | 将此属性列表（键和元素对）写入此 Properties 表中，以适合使用 load(Reader) 方法的格式写入输出字符流        |

## 26. 多线程

### 1. 实现多线程

#### 1. 进程

进程：是正在运行的程序

- 是系统进行资源分配和调用的独立单位
- 每一个进程都有它自己的内存空间和系统资源

#### 2. 线程

线程：是进程中的单个顺序控制流，是一条执行路径

- 单线程：一个进程如果只有一条执行路径，则称为单线程程序
- 多线程：一个进程如果有多条执行路径，则称为多线程程序

#### 3. 多线程的实现方式

方法 1：继承 Thread 类

- 定义一个类 MyThread 继承 Thread 类
- 在 MyThread 类中重写 run() 方法
- 创建 MyThread 类的对象
- 启动线程

两个小问题：

- 为什么要重写 run() 方法？

  因为 run() 是用来封装被线程执行的代码

- run() 方法和 start() 方法的区别？

  run()：封装线程执行的代码，直接调用，相当于普通方法的调用

  start()：启动线程；然后由 JVM 调用此线程的 run() 方法

#### 4. 设置和获取线程名称

Thread 类中设置和获取线程名称的方法

- void setName(String name)：将此线程的名称更改为等于参数 name
- String getName()：返回此线程的名称
- 通过构造方法也可以设置线程名称

如何获取 main() 方法所在的线程名称？

- public static Thread currentThread()：返回对当前正在执行的线程对象的引用

#### 5. 线程调度

线程有两种调度模型

- 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配给每个线程占用 CPU 的时间片
- 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些

Java 使用的是抢占式调度模型

假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU 时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行时有**随机性**，因为谁抢到 CPU 的使用权是不一定的

Thread 类中设置和获取线程优先级的方法

- public final in getPriority()：返回此线程的优先级

- public final void setPriority(int newPriority)：更改此线程的优先级

  线程默认优先级是 **5**，线程优先级的范围是：**1 - 10**

  线程优先级高仅仅表示线程获取的 CPU 时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果

#### 6. 线程控制

| 方法名                         | 说明                                                                  |
| ------------------------------ | --------------------------------------------------------------------- |
| static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数                      |
| void join()                    | 等待这个线程死亡                                                      |
| void setDaemon(boolean on)     | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java 虚拟机将退出 |

#### 7. 多线程的实现方式

方式 2：实现 Runable 接口

- 定义一个类 MyRunable 实现 Runable 接口
- 在 MyRunable 类中重写 run() 方法
- 创建 MyRunable 类的对象
- 创建 Thread 类的对象，把 MyRunable 对象作为构造方法的参数
- 启动线程

多线程的实现方案有两种

- 继承 Thread 类
- 实现 Runable 接口

相比继承 Thread 类，实现 Runable 接口的好处

- 避免了 Java 单继承的局限性
- 适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想

### 2. 线程同步

#### 1. 买票案例的思考

刚才讲了电影院卖票程序，好像没有什么问题。但是在实际生活中，售票时出票也是需要时间的，所以，在出售一张票的时候，需要一点时间的延迟，接下来我们去修改卖票程序中的卖票操作：每次出票时间 100 毫秒，用 sleep() 方法实现

卖票出现了问题

- 相同的票出现了多次
- 出现了负数的票

问题原因：

- 线程执行的随机性导致的

#### 2. 卖票案例数据安全问题的解决

为什么会出现问题？（这也是我们判断多线程程序是否会有数据安全问题的问题标准）

- 是否是多线程环境
- 是否有共享数据
- 是否有多条语句操作共享数据

如何解决多线程安全问题呢？

- 基本思想：让程序没有安全问题的环境

怎么实现呢？

- 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可
- Java 提供了同步代码块的方式来解决

#### 3. 同步代码块

锁多条语句操作共享数据，可以使用同步代码块实现

- 格式：

```java
synchronized(任意对象) {
    // 多条语句操作共享数据的代码
}
```

- synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁

同步的好处和弊端

- 好处：解决了多线程的数据安全问题
- 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率

#### 4. 同步方法

同步方法：就是把 synchronized 关键字加到方法上

- 格式：

  修饰符 **synchronized** 返回值类型 方法名(方法参数) { }

同步方法的锁对象是什么呢？

- **this**

同步静态方法：就是把 synchronized 关键字加到静态方法上

- 格式：

  修饰符 static **synchronized** 返回值类型 方法名(方法参数) { }

同步静态方法的锁对象是什么？

- **类名.class**

#### 5. 线程安全的类

StringBuffer

- 线程安全，可变字符序列
- 从版本 JDK5 开始，被 StringBuilder 替代。通常应该使用 StringBuilder 类，因为它支持所有相同的操作，但它更快，因为它不执行同步

Vector

- 从 Java 2 平台 v1.2 开始，该类改进了 List 接口，使其成为 Java Collections Framework 的成员。与新的集合实现不同，Vector 被同步。如果不需要线程安全的实现，建议使用 ArrayList 代替 Vector

Hashtable

- 该类实现了一个哈希表，它将键印射到值。任何非 null 对象都可以用作键或者值

- 从 Java 2 平台 v1.2 开始，该类进行了改进，实现了 Map 接口，使其成为 Java Collections Framework 的成员。

  与新的集合实现不同，Hashtable 被同步。如果不需要线程安全的实现，建议使用 HashMap 代替 Hashtable

#### 6. Lock 锁

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达式如何加锁和释放锁，JDK5 以后提供了一个新的锁对象 Lock

Lock 实现提供比 synchronized 方法和语句可以获得更广泛的锁定操作

Lock 中提供了获得锁和释放锁的方法

- void lock()：获得锁
- void unlock()：释放锁

Lock 是接口不能直接实例化，这里采用它的实现类 ReentrantLock 来实例化

ReentrantLock 的构造方法

- ReentrantLock()：创建一个 ReentrantLock 的实例

### 3. 生产者消费者

#### 1. 生产者消费者模式概述

生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻

所谓生产者消费者问题，实际上主要是包含了两类线程：

- 一类是生产者线程用于生产数据
- 一类是消费者线程用于消费数据

为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库

- 生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为
- 消费者只需要从共享数据区中获取数据，并不需要关心生产者的行为

为了体现生产和消费过程中的等待和唤醒，Java 就提供了几个方法供我们使用，这几个方法在 Object 类中 Object 类的等待和唤醒方法：

| 方法             | 说明                                                                          |
| ---------------- | ----------------------------------------------------------------------------- |
| void wait()      | 导致当前线程等待，直到令一个线程调用该对象的 notify() 方法或 notifyAll() 方法 |
| void notify()    | 唤醒正在等待对象监视器的单个线程                                              |
| void notifyAll() | 唤醒正在等待对象监视器的所有线程                                              |

#### 2. 生产者消费者案例

生产者消费者案例中包含的类：

- 奶箱类（Box）：定义一个成员变量，表示第 x 瓶奶，提供存储牛奶和获取牛奶的操作
- 生产者类（Producer）：实现 Runnable 接口，重写 run）方法，调用存储牛奶的操作
- 消费者类（Customer）：实现 Runnable 接口，重写 run）方法，调用获取牛奶的操作
- 测试类（BoxDemo）：里面有 main 方法，main 方法中的代码步骤如下
  1. 创建奶箱对象，这是共享数据区域
  2. 创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作
  3. 创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作
  4. 创建 2 个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递
  5. 启动线程

## 27. 网络编程

### 1. 网络编程入门

计算机网络

- 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统

网络编程

- 在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换

#### 2. 网络编程三要素

**IP 地址**

- 想要让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而 IP 地址就是这个标识号。也就是设备的标识

**端口**

- 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说 IP 地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识

**协议**

- 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一的规定，通信双方必须同时遵守才能完成数据交换。常见的协议有 UDP 协议和 TCP 协议

#### 3. IP 地址

IP 地址：是网络中设备的唯一标识

IP 地址分为两大类

- IPv4：是给每个连接在网络上的主机分配一个 32 bit 地址。按照 TCP/IP 规定，IP 地址用二进制来表示，每个 IP 地址长 32 bit，也就是 4 个字节。例如一个采用二进制的 IP 地址是“1100000010101000 00000001 01000010”，这么长的地址，处理起来太费劲了。为了方便使用，IP 地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的 IP 地址可以表示为“192.168.1.66”。IP 地址的这种表示法叫做“点分十进制表示法”，这显然比 1 和 0 容易记忆得多
- IPv6：由于互联网的蓬勃发展，IP 地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。为了扩大地址空间，通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，这样就解决了网络地址资源数量不够的问题

#### 3. IP 地址

常用命令：

- ipconfig：查看本机 IP 地址
- ping IP 地址：检查网络是否连通

特殊 IP 地址：

- 127.0.0.1：是会送地址，可以代表本机地址，一般用来测试使用

#### 4. InetAddress 的使用

为了方便我们对 IP 地址的获取和操作，Java 提供了一个类 InetAddress 供我们使用

InetAddress：此类表示 InetAddress 协议（IP）地址

| 方法名                                    | 说明                                                             |
| ----------------------------------------- | ---------------------------------------------------------------- |
| static InetAddress getByName(String host) | 确定主机名称的 IP 地址。主机名称可以是机器名称，也可以是 IP 地址 |
| Sting getHostName()                       | 获取此 IP 地址的主机名                                           |
| String getHostAddress()                   | 返回文本显示中的 IP 地址字符串                                   |

#### 5. 端口

端口：设备上应用程序的唯一标识

端口号：用于字节表示的整数，它的取值范围是 0 ~ 65535。其中，0 ~ 1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败

#### 6. 协议

协议：计算机网络中，连接和通信的规则被称为网络通信协议

**UDP 协议**

- 用户数据报协议（User Datagram Protocol）

- UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。

  由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输

- 例如视频会议通常采用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用 UDP 协议

**TCP 协议**

- 传输控制协议（Transmission Control Protocol）

- TCP 协议是**面向连接**的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间**可靠无差错**的数据传输。在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”

- 三次握手：TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠

  第一次握手，客户端向服务端发出连接请求，等待服务器确认

  第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求

  第三次握手，客户端再次向服务端发送确认信息，确认连接

- 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP 协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等

### 2. UDP 通信程序

#### 1. UDP 通信原理

UDP 协议是一种不可靠的网络协议，它在通信的两端建立一个 Socket 对象，但是这两个 Socket 只是发送，接收数据的对象

因此对于基于 UDP 协议的通信双方而言，没有所谓的客户端和服务器的概念

Java 提供了 DatagramSocket 类作为基于 UDP 协议的 Socket

#### 2. UDP 发送数据

发送数据的步骤

1. 创建发送端的 Socket 对象（DatagramSocket）

   DatagramSocket()

2. 创建数据，并把数据打包

   DatagramPacket(byte[] buf, int length, InetAddress address, int port)

3. 调用 DatagramSocket 对象的方法发送数据

   void send(DatagramPacket p)

4. 关闭发送端

   void close()

#### 3. UDP 接收数据

接收数据的步骤

1. 创建接收端的 Socket 对象（DatagramSocket）

   DatagramSocket(int port)

2. 创建一个数据包，用于接收数据

   DatagramPacket(byte[] buf, int length)

3. 调用 DatagramSocket 对象的方法接收数据

   void receive(DatagramPacket p)

4. 解析数据包，并把数据在控制台显示

   byte[] getData()

   int getLength

5. 关闭接收端

   void close()

### 3. TCP 通信程序

#### 1. TCP 通信原理

TCP 通信协议是一种可靠的网络协议，它在通信的两端各建立一个 Socket 对象，从而在通信的两端形参网络虚拟链路，一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信

#### 2. TCP 发送数据

发送数据的步骤

1. 创建客户端的 Socket 对象（Socket）

   Socket(String host, int port)

2. 获取输出流，写数据

   OutputStream getOutputStream()

3. 释放资源

   void close()

#### 3. TCP 接收数据

接收数据的步骤

1. 创建服务端的 Socket 对象（ServerSocket）

   ServerSocket(int port)

2. 监听客户端连接，返回一个 Socket 对象

   Socket accept()

3. 获取输入流，读数据，并把数据显示在控制台

   InputStream getInputStream()

4. 释放资源

   void close()

## 28. Lambda 表达式

### 1. 函数式编程思想概述

在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作”

面向对象思想强调“必须通过对象的形式来做事情”

函数式思想则尽量忽略面向对象的复杂语法:“强调做什么，而不是以什么形式去做”

而我们要学习的 Lambda 表达式就是函数式思想的体现

### 2. 体验 Lambda 表达式

需求：启动一个线程，在控制台输出一句话：多线程启动了

方式 1：

- 定义一个类 MyRunable 实现 Runable 接口，重写 run() 方法
- 创建 MyRunable 类的对象
- 创建 Thread 类的对象，把 MyRunable 的对象作为构造参数传递
- 启动线程

方式 2：

- 匿名内部类的方式改进

方式 3：

- Lambda 表达式的方式改进

### 3. Lambda 表达式的标准格式

匿名内容类中重写 run() 方法的代码分析

- 方法形式参数为空，说明调用方法时不需要传递参数
- 方法返回值类型为 void，说明方法执行没有结果返回
- 方法体中的内容，是我们具体要做的事情

Lambda 表达式的代码分析

- ()：里面没有内容，可以看成是方法形式参数为空
- ->：用箭头指向后面要做的事情
- { }：包含一段代码，我们称之为代码块，可以看成是方法体中的内容

组成 Lambda 表达式的三要素：**形式参数**，**箭头**，**代码块**

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("多线程程序启动了");
    }
}).start();
```

```java
new Thread(() -> {
    System.out.println("多线程程序启动了");
}).start();
```

Lambda 表达式的格式

- 格式：`(形式参数) -> { 代码块 }`
- 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可

### 4. Lambda 表达式的省略模式

省略规则：

- 参数规则：
- 参数可以省略。但是有多个参数的情况下，不能只省略一个
- 如果参数有且仅有一个，那么小括号可以省略
- 如果代码块的语句只有一条，那么可以省略大括号和分号，甚至是 return

### 5. Lambda 表达式的注意事项

注意事项：

- 使用 Lambda 必须要有接口，并且要求接口中有且仅有一个抽象方法

- 必须有上下文环境，才能推导出 Lambda 对应的接口

  根据**局部边的赋值**得知 Lambda 对应的接口：Runnable r = () -> System.out.println("Lambda 表达式");

  根据**调用方法的参数**得知 Lambda 对应的接口：new Thread(() -> System.out.println("Lambda 表达式")).start();

### 6. Lambda 表达式和匿名内部类的区别

所需类型不同

- 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类
- Lambda 表达式：只能是接口

使用限制不同

- 如果接口中有且仅有一个抽象方法，可以使用 Lambda 表达式，也可以使用匿名内部类
- 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用 Lambda 表达式

实现原理不同

- 匿名内部类：编译之后，产生一个单独的 .class 字节码文件
- Lambda 表达式：编译之后，没有一个单独的 .class 字节码文件，对应的字节码会在运行的时候动态生成

## 29. 接口组成更新

### 1. 接口组成更新概述

接口的组成

- 常量

  public static final

- 抽象方法

  public abstract

- 默认方法（Java 8）

- 静态方法（Java 8）

- 私有方法（Java 9）

### 2. 接口中默认方法

接口中默认方法的定义格式：

- 格式：public `default` 返回值类型 方法名(参数列表) { }

接口中默认方法的**注意事项**：

- 默认方法不是抽象方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉 default 关键字
- pubic 可以省略，default 不能省略

### 3. 接口中静态方法

接口中静态方法的定义格式：

- 格式：public static 返回值类型 方法名(参数列表) { }

接口静态方法的**注意事项**：

- 静态方法只能通过接口名称调用。不能通过实现类名或者对象名调用
- public 可以省略，static 不能省略

### 4. 接口中私有方法

Java 9 中新增了带方法体的私有方法，这其实在 Java 8 中就埋下了伏笔：Java 8 允许在接口中定义带方法体的默认方法和静态方法。这样可能会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是 Java 9 增加私有方法的必然性

接口中私有方法的定义格式：

- 格式 1：private 返回值类型 方法名(参数列表) { }
- 格式 2：private static 返回值类型 方法名(参数列表) { }

接口中私有的方法的**注意事项**：

- 默认方法可以调用私有的静态方法和非静态方法
- 静态方法只能调用私有的静态方法

## 30. 方法引用

### 1. 体验方法引用

在使用 Lambda 表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作

那么考虑一种情况：如果我们在 Lambda 中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？

答案肯定是没有必要

那我们又是如何使用已存在的方案的呢？

这就是我们要讲的方法引用，我们是通过方法引用来使用已经存在的方案

### 2. 方法引用符

方法引用符

- `::`该符号为引用运算符，而它所在的表达式被称为方法引用

回顾一下我们在体验方法引用中的代码

- Lambda 表达式：usePrintable(s -> System.out.println(s));

  分析：拿到参数 s 之后通过 Lambda 表达式，传递给 System.out.println 方法去处理

- 方法引用：usePrintable(System.out`::`println);

  分析：直接使用 System.out 中的 println 方法来取代 Lambda，代码更加的简洁

推导与省略

- 如果使用 Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导
- 如果使用方法引用，也是同样可以根据上下文进行推导
- 方法引用是 Lambda 的孪生兄弟

### 3. Lambda 表达式支持的方法引用

常见的引用方式：

- 引用类方法
- 引用对象的实例方法
- 引用类的实例方法
- 引用构造器

### 4. 引用类方法

引用类方法，其实就是引用类的静态方法

- 格式：`类名::静态方法`

### 5. 引用对象的实例方法

引用对象的实例方法，其实就是引用类中的成员方法

- 格式：`对象::成员方法`

### 6. 引用类的实例方法

引用类的实例方法，其实就是引用类中的成员方法

- 格式：`类名::成员方法`

### 7. 引用构造器

引用构造器，其实就是引用构造方法

- 格式：`类名::new`

## 31. 函数式接口

### 1. 函数式接口概述

函数式接口：有且仅有一个抽象方法的接口

Java 中的函数式编程体现就是 Lambda 表达式，所以函数式接口就是可以适用于 Lambda 使用的接口

只有确保接口中有且仅有一个抽象方法，Java 中的 Lambda 才能顺利地进行推导

如何检测一个接口是不是函数式接口呢？

- @FunctionalInterface
- 放在接口定义的上方：如果是函数式接口，编译通过；如果不是，编译失败

::: warning 注意

- 我们自己定义函数式接口的时候，@FunctionalInterface 是可选的，就算我们不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，**建议加上**该注解

:::

### 2. 函数式接口作为方法的参数

需求

- 定义一个类（RunnableDemo），在类中提供两个方法

  一个方法是：startThread（Runnable r）方法参数 Runnable 是一个函数式接口

  一个方法是主方法，在主方法中调用 startThread 方法

如果方法的参数是一个函数式接口，我们可以使用 Lambda 表达式作为参数传递

- startThread(() -> System.out.println(Thread.currentThread().getName + "线程启动了"));

### 3. 函数式接口作为方法的返回值

需求

- 定义一个类（ComparatorDemo），在类中提供两个方法

  一个方法是：Comparator \<String\> getComparator() 方法返回值 Comparator 是一个函数式接口

  一个方法是主方法，在主方法中调用 getComparator 方法

如果方法的返回值是一个函数式接口，我们可以使用 Lambda 表达式作为结果返回

```java
private static Comparator \<String\> getComparator() {
    return (s1, s2) -> s1.length - s2.length;
}
```

### 4. 常见的函数式接口

Java 8 在 java.util.function 包下预定义了大量的函数式接口供我们使用

我们重点来学习下面的 4 个接口

- Supplier 接口
- Consumer 接口
- Predicate 接口
- Function 接口

### 5. Supplier 接口

Supplier\<T\>：包含一个无参的方法

- T get()：获得结果
- 该方法不需要参数，它会按照某种实现逻辑（由 Lambda 表达式实现）返回一个数据
- Supplier\<T\> 接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的 get 方法就会生产什么类型的数据供我们使用

### 6. Consumer 接口

Consumer\<T\>：包含两个方法

- void accept：包含两个方法
- default Consumer \<T\> addThen(Consumer after)：返回一个组合的 Consumer，依次执行此操作，然后执行 after 操作
- Consumer \<T\> 接口也被称为消费型接口，它消费的数据的数据类型由泛型指定

### 7. Predicate 接口

Predicate\<T\>：常用的四个方法

- boolean test(T t)：对给定的参数进行判断（判断逻辑由 Lambda 表达式实现），返回一个布尔值
- default Predicate \<T\> negate()：返回一个逻辑的否定，对应逻辑非
- default Predicate \<T\> and(Predicate other)：返回一个组合判断，对应短路与
- default Predicate \<T\> or(Predicate other)：返回一个组合判断，对应短路或
- Predicate \<T\> 接口通常用于判断参数是否满足指定的条件

### 8. Function 接口

Function \<T, R\>：常用的两个方法

- R apply(T t)：将次函数应用于给定的参数
- default \<V\> Function andThen(Function after)：返回一个组合函数，首先将该函数应用于输入，然后将 after 函数应用于结果
- Function \<T, R\> 接口通常用于对参数进行处理，转换（处理逻辑由 Lambda 表达式实现），然后返回一个新的值
