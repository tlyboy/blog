---
title: Java 基础
date: 2022-3-22
categories:
  - Java 笔记
tags:
  - Java
---

## 1. Java 概述

### 1. Java 语言的发展史

#### 1. Java 语言

**语言**：人与人交流沟通的表达方式

**计算机语言**：人与计算机之间进行信息交流的一种特殊语言

::: tip

Java 语言是美国 **Sun** 公司在 1995 年推出的计算机语言

Java 之父：詹姆斯·高斯林（James Gosling）

:::

### 2. Java 语言跨平台原理

#### 1. 平台

指的是操作系统

- Windows
- Mac
- Linux

#### 2. 跨平台

Java 程序可以在任意操作系统上运行

#### 3. 跨平台原理

总结：在需要**运行 Java 程序**的操作系统上，安装一个与操作系统对应的 Java 虚拟机（**JVM Java Virtual Machine**）即可

### 3. JRE 和 JDK

#### 1. JRE（Java Runtime Environment）

是 Java 程序的运行环境，包含 **JVM** 和运行时所需要的核心类库。

我们想要**运行**一个已有的 Java 程序，那么只需安装 **JRE** 即可。

#### 2. JDK（Java Development Kit）

是 Java 程序的开发工具包，包含 **JRE** 和开发人员使用的工具。

其中的开发工具：编译工具（**javac.exe**）和运行工具（**java.exe**）。

我们想要**开发**一个全新的 Java 程序，那么必须安装 **JDK**。

#### 3. JDK、JRE、JVM 的关系

**JDK** 包含 **JRE** 和**开发工具**、**JRE** 含 **JVM** 和**核心类库**。

### 4. JDK 的下载和安装

#### 1. JDK 的下载

通过官方网站获取 JDK

JDK 8：[https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html](https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html)

::: warning 注意

针对不同的操作系统，下载对应的 JDK

:::

#### 2. JDK 的安装

傻瓜式安装，下一步即可。

::: tip 提示

建议安装到 C:\Program Files\Java 目录下。

如果只用一个版本，可以将版本号去除，方便日后更换也不用修改环境变量。

JDK 目录：C:\Program Files\Java\jdk

JRE 目录：C:\Program Files\Java\jre

如果要安装到其他盘下，只需修改盘符即可。

:::

#### 3. JDK 的安装目录

| 目录名称 | 说明                                                                    |
| :------: | ----------------------------------------------------------------------- |
| **bin**  | 该路径下存放了 JDK 的各种工具命令。`javac` 和 `java` 就存放在这个目录。 |
|   conf   | 该路径下存放了 JDK 的相关配置文件。                                     |
| include  | 该路径下存放了一些平台特点的头文件。                                    |
|  jmodes  | 该路径下存放了 JDK 的各种模块。                                         |
|  legal   | 该路径下存放了 JDK 各模块的授权文档。                                   |
|   lib    | 该路径下存放了 JDK 工具的一些补充 JAR 包。                              |

## 2. 第一个程序

### 1. 常用 DOS 命令

#### 1. 打开命令提示符窗口

1. 按下 win + R
2. 输入 cmd
3. 按下回车键

#### 2. 常用命令

| 操作                 | 说明                   |
| -------------------- | ---------------------- |
| 盘符名称：           | 盘符切换。             |
| `dir`                | 查看当前路径下的内容。 |
| `cd 目录`            | 进入单级目录。         |
| `cd ..`              | 回退到上一级目录。     |
| `cd 目录1\目录2\...` | 进入多级目录。         |
| `cd \`               | 回退到盘符目录。       |
| `cls`                | 清屏。                 |
| `exit`               | 退出命令提示符窗口。   |

### 2. Path 环境变量的配置

#### 1. 为什么要配置 Path 环境变量

开发 Java 程序，需要使用 JDK 提供的开发工具，而这些工具在 JDK 的安装目录的 bin 目录下。

为了在开发 Java 程序的时候，为了能够方便的使用 **javac** 和 **java** 这些命令，我们需要配置 **Path 环境变量**。

#### 2. 如何配置 Path 环境变量

**JAVA_HOME**（新建）：

```
C:\Program Files\Java\jdk
```

**Path**（添加）：

```
%JAVA_HOME%\bin
```

::: warning 注意

Path 是添加新的值，不要的原来的值删了。

:::

#### 3. 如何检测配置 Path 环境变量是否成功

在 cmd 中输入 `java` 或者 `javac -version`，出现提示信息。

### 3. HelloWorld 案例

#### 1. Java 程序开发运行流程

开发 Java 程序，需要三个步骤：**编写程序**，**编译程序**，**运行程序**

#### 2. HelloWorld 案例的编写

1. 新建文本文档文件，修改名称为 HelloWorld.java

2. 用记事本打开 HelloWorld 文件，书写程序内容

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}
```

#### 3. HelloWorld 案例的编译和运行

打开命令提示符窗口，进入到 HelloWorld.java 所在的目录。输入指令编译和执行。

编译：javac 文件名.java

范例：`javac HelloWorld.java`

<br>

执行：java 类名

范例：`java HelloWorld`

#### 4. BUG 的解决

1. 具备识别 BUG 的能力

   **多看**

2. 具备分析 BUG 的能力

   **多思考，多查阅资料**

3. 具备解决 BUG 的能力

   **多尝试，多总结**

### 4. HelloWorld 案例常见问题

- 中英文符号的问题

  **英文状态下的分号 —— 中文状态下的分号**

- 单词拼写的问题

  **System —— system**

## 3 .基础语法

### 1. 注释

#### 1. 注释概述

- 注释是在程序**指定位置**添加的**说性明信息**
- 注释不参与程序运行，仅起到**说明作用**

#### 2. 注释分类

- 单行注释

```java
// 注释信息
```

- 多行注释

```java
/* 注释信息 */
```

- 文档注释

```java
/** 注释信息 **/
```

::: tip

文档注释目前用不上，暂不讲解。

:::

### 2. 关键字

#### 1. 关键字概述

**关键字**：就是被 Java 语言赋予了**特定含义的单词**。

#### 2. 关键字的特点

- 关键字的字母**全部小写**。
- 常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观。

### 3. 常量

#### 1. 常量概述

**常量**：在程序运行过程中，其值不可改变的量。

#### 2. 常量分类

|  常量类型  | 说明                 |
| :--------: | -------------------- |
| 字符串常量 | 用双引号括起来的内容 |
|  整数常量  | 不带小数的数字       |
|  小数常量  | 带小数的数字         |
|  字符常量  | 用单引号括起来的内容 |
|  布尔常量  | 布尔值               |
|   空常量   | 一个特殊的值，空值   |

### 4. 数据类型

#### 1. 数据类型

Java 语言是强类型语言，对于每一种数据都给出了明确的数据类型，不同的**数据类型**也分配了不同的**内存空间**，所以它们表示的**数据大小**也是不一样的。

#### 2. 数据类型内存占用情况和取值范围

1. 整数型

| 关键字  | 内存占用 |                  取值范围                  |
| :-----: | :------: | :----------------------------------------: |
| `byte`  |    1     |                 -128 ~ 127                 |
| `short` |    2     |               -32768 ~ 32767               |
|  `int`  |    4     |          -2147483648 ~ 2147483647          |
| `long`  |    8     | -9223372036854775808 ~ 9223372036854775807 |

2. 浮点数

|  关键字  | 内存占用 |             取值范围              |
| :------: | :------: | :-------------------------------: |
| `float`  |    4     |      1.4E-45 ~ 3.4028235E38       |
| `double` |    8     | 4.9E-324 ~ 1.7976931348623157E308 |

3. 字符

| 关键字 | 内存占用 | 取值范围  |
| :----: | :------: | :-------: |
| `char` |    2     | 0 ~ 65535 |

4. 布尔

|  关键字   | 内存占用 |  取值范围   |
| :-------: | :------: | :---------: |
| `boolean` |    1     | true，false |

### 5. 变量

#### 1.变量概述

**变量**：在程序运行过程中，其值可变的量。

从本质上讲，变量是内存中的一小块区域。

#### 2. 变量定义

- 格式：数据类型 变量名 = 变量值;
- 范例：`int a = 10；`

#### 3. 变量的使用

变量的使用：取值和修改值

- 取值格式：变量名
- 范例：`a`

<br>

- 修改值格式：变量名 = 变量值;
- 范例：`a = 20;`

#### 4. 变量使用的注意事项

- **名字不能重复**
- **变量未赋值，不能使用**
- **long 类型的变量定义的时候，为了防止整数过大，后面要加 L**
- **float 类型的变量定义的时候，为了防止类型不兼容，后面要加 F**

### 6. 标识符

#### 1. 标识符概述

**标识符**：就是给类，方法，变量等起名字的**符号**。

#### 2. 标识符定义规则

- 由**数字**、**字母**、**下划线**（\_）和**美元符**（$）组成
- 不能以数字开头
- 不能是关键字
- 区分大小写

#### 3.常见命名约定

小驼峰命名法：**方法、变量**

- 约定 1：标识符是一个单词的时候，首字母小写
- 范例 1：`name`

<br>

- 约定 2：标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写
- 范例 2：`firstName`

大驼峰命名法：**类**

- 约定 1：标识符是一个单词的时候，首字母大写
- 范例 1：`Student`

<br>

- 约定 2：标识符由多个单词组成的时候，每个单词的首字母大写
- 范例 2：`GoodStudent`

### 7. 类型转换

#### 1. 类型转换分类

- 自动类型转换
- 强制类型转换

#### 2. 自动类型转换

把一个表示数据**范围小的数值**或者**变量**赋值给另一个表示**数据范围大的变量**

范例: `double = 10;`

数据范围从小到大

- byte —— short —— int —— long —— float —— double

- char —— int

#### 3. 强制类型转换

把一个表示数据**范围大的数值**或者**变量**赋值给另一个表示数据**范围小的变量**

- 格式：**目标数据类型 变量名=(目标数据类型)值或者变量;**

## 4. 运算符

### 1. 算数运算符

#### 1. 运算符和表达式

- 运算符：对常量或者变量进行操作的**符号**

- 表达式：

  用**运算符**把常量或者变量连接起来**符合 Java 语法的式子**就可以称为表达式。

  不同运算符合连接的表达式体现的是不同类型的表达式。

- 举例说明：

  int a = 10;

  int b = 20;

  int c = a + b;

  <br>

  **+：是运算符**，并且是算术运算符

  **a + b：是表达式**，由于+是算术运算符，所以这个表达式叫算术表达式

#### 2. 算数运算符

| 符号 | 作用 |
| :--: | :--: |
| `+`  |  加  |
| `-`  |  减  |
| `*`  |  乘  |
| `/`  |  除  |
| `%`  | 取余 |

::: warning 注意

**/** 和 **%** 的区别：两个数据做除法，**/** 取结果的**商**，**%** 取结果的**余数**。

整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。

:::

#### 3. 字符的 “+” 操作

拿字符在计算机底层**对应的数值**来进行计算的

**'A' ——> 65 A —— Z 是连续的**

**'a' ——> 97 a —— z 是连续的**

**'0' ——> 48 0 —— 9 是连续的**

算数表达式中**包含多个基本数据类型**的值得时候，整个算数表达式的**类型**会**自动进行提升**。

提升规则：

- byte 类型，short 类型和 char 类型将被提升到 int 类型

- 整个表达式的类型自动提升到表达式中最高等级操作数同样的类型

  等级顺序：byte，short，char ——> int——> long ——> float ——> double

#### 4. 字符串的 “+” 操作

当 “+” 操作中出现字符串时，这个 “+” **是字符串连接符**，而不是算数运算。

- "xxx" + 666

当 “+” 操作中，出现了字符串，就是连接运算符，否则就是算数运算符。当连续进行 “+” 操作时，从左到右逐个执行。

- 1 + 99 + "xxx"

### 2. 赋值运算符

#### 1. 赋值运算符

| 符号 |    作用    |
| :--: | :--------: |
| `=`  |    赋值    |
| `+=` |  加后赋值  |
| `-=` |  减后赋值  |
| `*=` |  乘后赋值  |
| `/=` |  除后赋值  |
| `%=` | 取余后赋值 |

### 3. 自增自减运算符

#### 1. 自增自减运算符

| 符号 | 作用 |
| :--: | :--: |
| `++` | 自增 |
| `--` | 自减 |

::: warning 注意

- \+ \+ 和 \- \- 即可以放在变量的后边，也可以放在变量的前边。

- 单独使用的时候，\+ \+ 和 \- \- 无论是放在变量的前边还是后边，结果是一样的。

- 参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做 \+ \+ 或者 \- \-。

  参与操作的时候，如果放在变量的前边，先拿变量做 \+ \+ 或者 \- \-，后拿变量参与操作。

:::

最常见的用法：**单独使用**

### 4. 关系运算符

#### 1. 关系运算符

| 符号 | 说明                                                              |
| :--: | ----------------------------------------------------------------- |
| `==` | a==b，判断 a 和 b 的值是否**相等**，成立为 true，不成立为 false   |
| `!=` | a!=b，判断 a 和 b 的值是否**不相等**，成立为 true，不成立为 false |
| `>`  | a>b，判断 a 是否**大于** b,成立为 true，不成立为 false            |
| `>=` | a>=b，判断 a 是否**大于等于** b，成立为 true，不成立为 false      |
| `<`  | a<b，判断 a 是否**小于** b，成立为 true，不成立为 false           |
| `<=` | a<=b，判断 a 是否**小于等于** b，成立为 true，不成立为 false      |

::: warning 注意

关系运算符的**结果**都是 **boolean** 类型，要么是 true，要么是 false。

千万不要把 “= =” 误写成 “=” 。

:::

### 5. 逻辑运算符

#### 1. 逻辑运算符概述

在数学中，一个数据 x，大于 3，小于 6，我们可以这样来进行表示：**3 < x < 6**。

在 Java 中，需要把上面的式子先进行拆解，再进行合并表达。

- 拆解为：x > 3 和 x < 6
- 合并后：x > 3 && x < 6

&&其实就是一个逻辑运算符。

我们可以这样说，逻辑运算符，是用来**连接关系表达式**的运算符。

当然，逻辑运算符也可以直接**连接布尔类型的常量或者变量**。

#### 2 .逻辑运算符

| 符号 |   作用   | 说明                                             |
| :--: | :------: | ------------------------------------------------ | -------------------------------------------------- |
| `&`  |  逻辑与  | a&b，a 和 b 都是 true，结果为 true，否则为 false |
|  `   |    `     | 逻辑或                                           | a\|b，a 和 b 都是 false，结果为 false，否则为 true |
| `^`  | 逻辑异或 | a^b，a 和 b 结果不同为 true，相同为 false        |
| `!`  |  逻辑非  | !a，结果和 a 的结果正好相反                      |

#### 3 .短路逻辑运算符

| 符号 |  作用  | 说明                          |
| :--: | :----: | ----------------------------- | ------ | ------------------------------ |
| `&&` | 短路与 | 作用和 & 相同，但是有短路效果 |
|  `   |        | `                             | 短路或 | 作用和 \| 相同，但是有短路效果 |

::: warning 注意

- 逻辑与 **&** ，无论左边真假，右边都要执行。

  短路与 **&&** ，如果左边为真，右边执行；如果**左边为假，右边不执行**。

- 逻辑或 **|** ，无论左边真假，右边都要执行。

  短路或 **||** ，如果左边为假，右边执行；如果**左边为真，右边不执行**。

最常用的逻辑运算符：**\&\&，\|\|，\!**

:::

### 6. 三元运算符

#### 1. 三元运算符

- 格式：关系表达式 **?** 表达式 1 : 表达式 2;
- 范例:：**a > b ? a : b**;

计算规则：

- 首先计算**关系表达式的值**

- 如果值为 **true，表达式 1 的值**就是运算结果

- 如果值为 **false，表达式 2 的值**就是运算结果

## 5. 数据输入

### 1. Scanner 使用的基本步骤

1. 导包

```java
import java.util.Scanner;
// 导包的动作必须出现在类定义的上边
```

2. 创建对象

```java
Scanner sc = new Scanner(System.in);
// 上面这个格式里面，只有 sc 是变量名，可以变，其他的都不允许变。
```

3. 接受数据

```java
int i = sc.nextInt();
// 上面这个格式里面，只有 i 是变量名，可以变，其他的都不允许变。
```

## 6. 分支语句

### 1.流程控制

#### 1. 流程控制语句分类

- 顺序结构
- 分支结构（`if，switch`）
- 循环结构（`for，while，do ... while`）

#### 2. 顺序结构

顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行,程序中大多数的代码都是这样执行的。

### 2. if 语句

#### 1. if 语句格式 1

格式：

```java
if (关系表达式) {

	语句体;

}
```

执行流程：

1. 首先计算关系表达式的值
2. 如果关系表达式的值为 true 就执行语句体
3. 如果关系表达式的值为 false 就不执行语句体
4. 继续执行后面的语句内容

#### 2. if 语句格式 2

格式：

```java
if (关系表达式) {

	语句体1;

} else {

	语句体2;

}
```

1. 首先计算关系表达式的值
2. 如果关系表达式的值为 true 就执行语句体 1
3. 如果关系表达式的值为 false 就执行语句体 2
4. 继续执行后面的语句内容

#### 4. if 语句格式 3

格式：

```java
if (关系表达式1) {

	语句体1;

} else if (关系表达式2){

	语句体2;

}

	...

	else {

		语句体n + 1;

}
```

执行流程：

1. 首先计算关系表达式 1 的值
2. 如果值为 true 就执行语句体 1；如果值为 false 就计算关系表达式 2 的值
3. 如果值为 true 就执行语句体 2；如果值为 false 就计算关系表达式 3 的值
4. ...
5. 如果没有任何关系表达式为 true，就执行语句体 n+1。

### 3. switch 语句格式

格式：

```java
switch(表达式){

	case 值1:

		语句体1;

		break;

	case 值2:

		语句体2;

		break;

	default:

		语句体n+1;

		[break;]

}
```

格式说明：

- 表达式：取值为 byte、short、int、char，JDK 5 以后可以是枚举，JDK 7 以后可以是 String。
- case：后面跟的是要和表达式进行比较的值。
- break：表示中断，结束的意思，用来结束 switch 语句。
- default：表示所有情况都不匹配的时候，就执行该处的内容，和 if 语句的 else 相似。

执行流程：

1. 首先计算表达式的值。
2. 依次和 case 后面的值进行比较，如果有对应的值，就会执行相应的语句，在执行的过程中，遇到 break 就会结束。
3. 如果所有的 case 后面的值和表达式的值都不匹配，就会执行 default 里面的语句体，然后程序结束掉。

## 7. 循环语句

### 1. for 循环语句

#### 1. 循环结构

**特征：**

重复做某件事情

具有明确的开始和结束标志

**循环结构的组成：**

初始化语句：用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样。

条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去。

循环体语句：用于表示循环反复执行的内容，简单说就是循环反复执行的事情。

条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去。

**循环结构对应的语法：**

初始化语句：这里可以是一条或者多条语句，这些语句可以完成一些初始化操作。

条件判断语句：这里使用一个结果为 boolean 类型的表达式，这个表达式能够决定是否执行循环体。

循环体语句：这里可以是任意语句，这些语句反复执行

条件控制语句：这里通常是使用一条语句来改变变量的值，从而达到控制循环是否继续向下执行的效果。

#### 2. for 循环语句格式

格式：

```java
for (初始化语句; 条件判断语句; 条件控制语句) {
    循环体语句;
}
```

执行流程：

1. 执行初始化语句

2. 执行条件判断语句，看其结果是 true 还是 false

   如果是 false，循环结束

   如果是 true，继续执行

3. 执行循环体语句

4. 执行条件控制语句

5. 回到 2 继续

### 2. while 循环语句

#### 1. while 循环语句格式

基本格式：

```java
while (条件判断语句) {
    循环体语句;
}
```

完整格式：

```java
初始化语句;
while (条件判断语句) {
    循环体语句;
    条件控制语句;
}
```

执行流程：

1. 执行初始化语句

2. 执行条件判断语句，看其结果是 true 还是 false

   如果是 false，循环结束

   如果是 true，继续执行

3. 执行循环体语句

4. 执行条件控制语句

5. 回到 2 继续

### 3. do...while 循环语句

#### 1. do...while 循环语句格式

基本格式：

```java
do {
    循环体语句;
} while (条件判断语句);
```

完整格式：

```java
初始化语句;
do {
    循环体语句;
    条件控制语句;
} while (条件判断语句);
```

执行流程：

1. 执行初始化语句

2. 执行循环体语句

3. 执行条件控制语句

4. 执行条件判断语句，看其结果是 true 还是 false

   如果是 false，循环结束

   如果是 true，继续执行

5. 回到 2 继续

#### 2. 三种循环的区别

**三种循环的区别：**

- for 循环和 while 循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）
- do...while 循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）

**for 和 while 的区别：**

- 条件控制语句所控制的自增变量，因为归属 for 循环的语法结构中，在 for 循环结束后，就不能再次被访问到了
- 条件控制语句所控制的自增变量，对于 while 循环来说不归属其语法结构中，在 while 循环结束后，该变量还可以继续使用

死循环格式：

```java
for(;;){ }

while(true){ }

do{ }while(true);
```

**while 的死循环格式是最常用的**

**命令提示符窗口中 Ctrl + C 可以结束死循环**

### 4. 控制跳转语句

#### 1. 跳转控制语句概述

- continue 用来循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行
- break 用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环

### 5. 循环嵌套

#### 1. 循环嵌套概述

语句结构：

- 顺序语句以分好结尾，表示一句话的结束

- 分支语句

  一对大括号表示 if 的整体结构，整体描述一个完整的 if 语句

  一对大括号表示 switch 的整体结构，整体描述一个完整的 switch 语句

- 循环语句

  一对大括号表示 for 的整体结构，整体描述一个完整的 for 语句

  一对大括号表示 while 的整体结构，整体描述一个完整的 while 语句

  do...while 以分号结尾，整体描述一个完整的 do...while 语句

任何语句对外都可以看成是一句话，一句代码

分支语句中包含分支语句称为分支嵌套

循环语句中包含循环语句称为**循环嵌套**

### 6. Random

#### 1. Random

作用：用于产生一个随机数

使用步骤：

1. 导包

   ```java
   import java.util.Random;
   // 导包的动作必须出现在类定义的上面
   ```

2. 创建对象

   ```java
   Random r = new Random();
   // 上面这个格式里面，r 是变量名，可以变，其他的都不允许变
   ```

3. 获取随机数

   ```java
   int number = r.nextInt(10); // 获取数据的范围：[0, 10]包括 0，不包括 10
   // 上面这个格式里面，number 是变量，可以变，数字 10 可以变，其他的都不允许变
   ```

## 8. IDEA

### 1. IDEA 概述和安装

#### 1. IDEA 概述

IDEA 全称**Intellij IDEA**，是用于 Java 语言开发的集成环境，它是世界公认的目前用于 Java 程序开发最好的工具。

**集成环境**：把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。

**IDEA 的下载和安装**

下载：[https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)

安装：傻瓜式安装，建议修改安装路径。

### 2. IDEA 中 HelloWorld

#### 1. IDEA 中 HelloWorld 步骤

1. 创建一个空项目
2. 创建一个新模块
3. 在模块的 src 下创建一个包
4. 在包下创建一个类
5. 在 idea 中执行程序

### 3. IDEA 中内容辅助键和快捷键

#### 1. 内容辅助键

- **快速生成语句**

  快速生成 main() 方法：`psvm`，回车

  快速生成输出语句：`sout`，回车

- **内容辅助键**

  Ctrl + Alt + space（内容提示，代码补全等）

#### 2. 快捷键

- **注释**

  单行：选中代码，Ctrl + /，再来一次，就是取消

  多行：选中代码，Ctrl + shift + /，再来一次，就是取消

- **格式化**

  Ctrl + Alt + L

### 4. IDEA 中模块的操作

#### 1. IDEA 中模块操作分类

- 新建模块
- 删除模块
- 导入模块

## 9. 数组

### 1. 数组定义格式

#### 1. 数组概述

- 一次性声明**大量**用于存储数据的变量
- 要存储的数据通常都是**同类型数据**

#### 2. 什么是数组

数组（array）是一种用于存储**多个相同类型**数据的存储模型

### 3. 数组的定义格式

- 格式一：`数据类型[] 变量名`
- 格式而：`数据类型 变量名[]`

### 2. 数组初始化之动态初始化

#### 1. 数组初始化概述

Java 中的数组必须先初始化，然后才能使用

所谓初始化：就是为数组中的元素分配内存空间，并为每个数组元素赋值

### 2. 数组的初始化方式

- 动态初始化
- 静态初始化

#### 3. 动态初始化

动态初始化：初始化时只指定数组长度，由系统为数组分配初始值

- 格式：`数组类型[] 变量名 = new 数据类型[数组长度];`

### 3. 数组元素访问

#### 1. 数组元素访问

- 数组变量访问方式
- 格式：`数组名`

<br>

- 数组内部保存的数据的访问方式
- 格式：`数组名[索引]`

<br>

- 索引是数组中数据的编号方式
- 作用：索引用于访问数组中的数据使用，`数组名[索引]`等同于变量名，是一种特殊的变量名
- 特征：
  1. 索引从 0 开始
  2. 索引是连续的
  3. 索引逐一增加，每次加 1

### 4. 内存分配

#### 1. Java 中内存分配

Java 程序在运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。

数组在初始化时，会为存储空间添加默认值

- 整数：默认值 0
- 浮点数：默认值 0.0
- 布尔值：默认值 false
- 字符：默认值是空字符
- 引用数据类型：默认值是 `null`

<br>

- 栈内存：存储局部变量

定义在方法中的变量

使用完毕，立即消失

- 堆内存：存储 new 出来的内容（实体，对象）

数组在初始化时，会为存储空间添加默认值

每 new 出来的东西都有一个地址值

使用完毕，会在垃圾回收器空闲时被回收

### 5. 数组初始化之静态初始化

#### 1. 数组初始化之静态初始化

静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度

- 格式：`数据类型[] 变量名 = new 数据类型 [] {数据1, 数据2, 数据3, ...... };`
- 简化格式：`数据类型[] 变量名 = {数据1, 数据2, 数据3, ...... };`

### 6. 数组操作的两个常见小问题

- 索引越界：访问了数组中不存在的索引对应的元素，造成索引越界问题
- 空指针异常：访问的数组已经不再指向堆内存的数据，造成空指针异常
- null：空值，引用数据类型的默认值，表示不指向任何有效对象

### 7. 数组常见操作

#### 1. 遍历

#### 2. 获取数组元素数量

- 格式：数组名.**length**
- 遍历通用格式

#### 3. 获取最值

思路：

1. 定义一个变量，用于保存最大值（或最小值）
2. 取数据中第一个数据作为变量的初始值
3. 与数组中剩余的数据逐个比对

## 10. 方法

### 1. 方法概述

- **方法**是（method）是将具有独立功能的**代码块**组织称为一个整体，使其具有特殊功能的**代码集**

注意：

- 方法必须先创建才可以使用，该过程称为方法定义
- 方法创建后并不是直接运行的，需要手动使用后才执行该过程称为方法调用

### 2. 方法的定义和调用

#### 1. 方法的定义

- 格式：

```java
public static void 方法名 () {
    // 方法体
}
```

#### 2. 方法的调用

- 格式：

```java
方法名();
```

::: warning 注意

- 方法必须先定义后调用，否则程序将报错

:::

### 3. 带参数方法的定义和调用

#### 1. 带参数方法的定义

- 格式

```java
public static void 方法名 (参数) {... ...}
```

- 格式（单个参数）：

```java
public static void 方法名 (数据类型 变量名) {... ...}
```

- 格式（多个参数）：

```java
public static void 方法名 (数据类型 变量名1, 数据类型 变量名2, ......) {... ...}
```

::: warning 注意

- 方法定义时，参数中的**数据类型**与**变量名**都不能缺少，缺少任意一个程序将报错
- 方法定义时，多个参数之间使用逗号（ , ）分隔

:::

#### 2. 带参数方法的调用

- 格式：

```java
方法名(参数);
```

- 格式（单个参数）：

```java
方法名(变量名/常量值);
```

- 格式（多个参数）：

```java
方法名(变量名/常量值1, 变量名/常量值2);
```

::: warning 注意

- 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错

:::

#### 3. 形参和实参

- 形参：方法定义中的参数

  等同于变量定义的格式

- 实参：方法调用中的参数

  等同于使用变量或常量

### 4. 带返回值方法的定义和使用

#### 1. 带返回值方法的定义

- 格式：

```java
public static 数据类型 方法名 (参数) {
    return 数据;
}
```

::: warning 注意

- 方法定义时 return 后面的返回值与方法定义上的数据类型要匹配，否则程序将报错

:::

#### 2. 带返回值方法调用

- 格式 1：

```java
方法名(参数);
```

- 格式 2：

```java
数据类型 变量名 = 方法名(参数);
```

::: warning 注意

- 方法的返回值通常会使用变量接收，否则该返回值将无意义

:::

### 5. 方法的注意事项

#### 1. 方法注意事项

- 方法不能嵌套定义
- void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据

#### 2. 方法的通用格式

- 格式：

```java
public static 返回值类型 方法名 (参数) {
    // 方法体
    return 数据;
}
```

- public static：修饰符，目前先记住这个格式

- 返回值类型：

  方法操作完毕之后返回的数据的数据类型

  如果方法操作完毕，没有数据返回，这里写 void，而且方法体中一般不写 return

- 方法名：调用方法时候使用的标识

- 参数：由数据类型和变量名组成，多个参数之间用逗号隔开

- 方法体：完成功能的代码块

- 定义方法时，要做到**两个明确**

  明确方法返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写 void；如果有，写对应的数据类型

  明确参数：主要是明确参数的类型和数量

- 调用方法时

  void 类型的方法，直接调用即可

  非 void 类型的方法，推荐用变量接收调用

### 6. 方法重载

#### 1. 方法重载概述

方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载。

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同，类型不同或者数量不同

#### 2. 方法重载特点

- 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式
- 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载

### 7. 方法的参数传递

#### 1. 方法参数传递（基本类型）

对于基本数据类型的参数，形式参数的改变，不影响实际参数的值

#### 2. 方法参数传递（引用类型）

对于引用类型的参数，形式参数的改变，影响实际参数的值

## 11. Debug

### 1. Debug 概述

**Debug**：是供程序员使用的程序调试工具，它可以用于**查看程序**的**执行流程**，也可以用于追踪程序执行过程来**调试程序**。

### 2. Debug 操作流程

Debug 调试，又被称为断点调试，断点其实是一个标记，告诉我们从哪里开始看

1. 如何加断点
2. 如何运行加了断点的程序
3. 看哪里
4. 点哪里
5. 如何删除断点

#### 1. 如何加断点

选择要设置断点的代码行，在行号的区域后面点击鼠标左键即可。

#### 2. 如何运行加了断点的程序

在代码区域右键 Debug 执行

#### 3. 看哪里

看 Debugger 窗口

看 Console 窗口

#### 4. 点哪里

点 Step into（F7）这个箭头，也可以直接按 F7

点 stop 结束

#### 5. 如何删除断点

选择要删除的断点，单击鼠标左键即可。

如果是多个断点，可以每一个再点击一次。也可以一次性全部删除。

## 12. 面向对象基础

### 1. 类和对象

#### 1. 什么是对象

万物皆对象，客观存在的事物皆为对象

#### 2. 什么是面向对象

面向对象(Object Oriented)是软件开发方法，一种编程范式。

#### 3. 什么是类

类是对显示生活中一类具有**共同属性**和**行为**的事物的抽象

**类的特点：**

- 类是对象的数据类型
- 类是具有相同属性的行为的一组对象的集合

#### 4. 什么是对象的属性

**属性** ：对象具有的各种特征，每个对象的每个**属性**都拥有特定的**值**

#### 5. 什么是对象的行为

**行为**：对象能够执行的操作

#### 6.类和对象的关系

**类**：类是对现实生活中一类具有共同属性和行为的事物的抽象

**对象**：是能够看得到摸得到的真实存在的实体

#### 7. 类的定义

类的重要性：是 Java 程序的基本组成单位

类是什么：是对现实生活中一类具有**共同属性**和**行为**的事物的抽象，确定对象将会拥有的属性和行为

类的组成：**属性**和**行为**

- 属性：在类中通过**成员变量**来体现（类中方法外的变量）
- 行为：在类中通过**成员方法**来体现（和前面的方法相比去掉 static 关键字即可）

**类的定义步骤：**

1. 定义类
2. 编写类的成员变量
3. 编写类的成员方法

```java
public class 类名 {
    //成员变量
    变量1的数据类型 变量1;
    变量2的数据类型 变量2;
    ...
    //成员方法
    方法1;
    方法2;
    ...
}
```

#### 8. 对象的使用

创建对象

- 格式：`类名 对象名 = new 类名();`

使用对象

1. **使用成员变量**
   - 格式：`对象名.变量名`
2. **使用成员方法**
   - 格式：`对象名.方法名()`

### 2. 成员变量和局部变量

#### 1. 什么是成员变量和局部变量

成员变量：类中方法外的变量

局部变量：方法中的变量

#### 2. 成员变量和局部变量区别

| 区别           | 成员变量                                   | 局部变量                                       |
| -------------- | ------------------------------------------ | ---------------------------------------------- |
| 类中位置不同   | 类中方法外                                 | 方法内或者方法声明上                           |
| 内存中位置不同 | 堆内存                                     | 栈内存                                         |
| 生命周期不同   | 随着对象的存在而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的调用完毕而消失 |
| 初始化值不同   | 有默认的初始化值                           | 没有默认的初始化值，必须先定义，赋值，才能使用 |

### 3. 封装

#### 1. private 关键字

- 是一个权限修饰符
- 可以修饰成员（成员变量和成员方法）
- 作用是保护成员不被别的类使用，被 `private` 修饰的成员只在本类中才能访问

针对 `private` 修饰的成员变量，如果需要被其他类使用，提供相应的操作

- 提供“ `get 变量名()`”方法，用于获取成员变量的值，方法用 `public` 修饰
- 提供“ `set 变量名(参数)`”方法，用于设置成员变量的值，方法用 `public` 修饰

#### 2. private 关键字的使用

一个标准类的编写：

- 把成员变量用 `private` 修饰
- 提供对应的 `getXxx()/setXxx()` 方法

#### 3. this 关键字

1. this 修饰的变量用于指代成员变量
   - 方法的形参如果与成员变量同名，不带 this 修饰的变量指的是形参，而不是成员变量
   - 方法的形参没有与成员变量同名，不带 this 修饰的变量指的是成员变量
2. 什么时候使用 this 呢？**解决局部变量隐藏成员变量**
3. this：代表所在类的对象引用
   - 记住：方法被哪个对象调用，this 就代表哪个对象

#### 5. 封装

##### **1. 封装概述**

是面向对象三大特征之一（**封装，继承，多态**）
是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的

##### **2. 封装原则**

将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量 `private`，提供对应的 `getXxx()/setXxx()` 方法

##### **3. 封装好处**

通过方法来控制成员变量的操作，提高了代码的安全性

把代码用方法进行封装，提高了代码的复用性

### 4. 构造方法

#### 1. 构造方法概述

构造方法是一种特殊的方法

作用：创建对象

格式：

```java
public class 类名 {
    修饰符 类名 (参数) {
    }
}
```

功能：主要是完成对象数据的初始化

#### 2. 构造方法的注意事项

1. 构造方法的创建

- 如果没有定义构造方法，系统将给出一个**默认**的**无参数构造方法**
- 如果定义了构造方法，系统将不再提供默认的构造方法

2. 构造方法的重载

- 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法

3. 推荐的使用方式

- **无论是否使用，都手工书写无参数构造方法**

#### 3. 标准类的制作

1. 成员变量
   - 使用 `private` 修饰
2. 构造方法
   - 提供一个无参构造方法
   - 提供一个带多个参数的构造方法
3. 成员方法
   - 提供每一个成员变量对应的 `setXxx()/getXxx()`
   - 提供一个显示对象信息的 `show()`
4. 创建对象并为其成员变量赋值的两种方式
   - 无参构造方法创建对象后使用 `setXxx()` 赋值
   - 使用带参构造方法直接创建带有属性值的对象

## 13. String

### 1. API

#### 1. API 概述

**API**(**A**pplication **P**rogramming **I**nterface)：应用程序编程接口

Java API：指的就是 JDK 中提供的各种功能的 Java 类

#### 2. 如何使用帮助文档

1. 右键打开该文档
2. 找到索引选项卡中的输入框
3. 在输入框中输入 Random
4. 看在哪个包下
5. 看类的描述
6. 看构造方法
7. 看成员方法

#### 3. API 使用练习

::: warning 注意

**调用方法的时候，如果方法有明确的返回值，我们用变量接收**

**可以手动完成，也可以使用快捷键的方式完成(Ctrl + Alt + V)**

:::

### 2. String

#### 1. String 概述

String 类在 `java.lang` 包下，所以使用的时候不需要导包

`String` 类代表**字符串**，Java 程序中的所有字符串文字（例如 "abc"）

也就是说，**Java 程序中所有的双引号字符串，都是 String 类的对象**

字符串的特点

- 字符串不可变，它们的值在创建后不能被更改
- 虽然 String 的值是不可变的，但它们可以被共享
- 字符串效果上相当于字符数组（`char[]`），但是底层原理是字节数组（`byte[]`）

::: tip

**JDK 8 及以前是字符数组，JDK 9 及以后是字节数组**

:::

#### 2. String 构造方法

| 方法名                       | 说明                                       |
| ---------------------------- | ------------------------------------------ |
| `public String ()`           | 创建一个空白字符串对象，不含有任何内容     |
| `public String (char[] chs)` | 根据字符数组的内容，来创建字符串对象       |
| `public String (byte[] bys)` | 根据字节数组的内容，来创建字符串对象       |
| `String s = "abc";`          | 直接赋值的方式创建字符串对象，内容就是 abc |

#### 3. String 对象的特点

1. 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

```java
char[] chs = {'a', 'b', 'c'};
String s1 = new String(chs);
String s2 = new String(chs);
```

上面的代码中，JVM 会首先创建一个字符数组，然后每一次 new 的时候都会有一个新的地址，只不过 s1 和 s2 参考的字符串内容是相同的

2. 以""方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都会只建立一个 String 对象，并在字符串池中维护

```java
String s3 = "abc";
String s4 = "abc";
```

在上面的代码中，针对第一行代码，JVM 会建立一个 String 对象放在字符串池中，并给 s3 参考;

第二行则让 s4 直接参考字符串池中的 String 对象，也就是说它们本质上是同一个对象

#### 4. 字符串的比较

使用`==`做比较

- 基本类型：比较的是**数据值**是否相同
- 引用类型：比较的是**地址值**是否相同

字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫：`equals()`

- `public boolean equals (Object anObject)`：将此字符串与指定对象进行比较。由于我们比较的是字符串对象，所以参数直接传递一个字符串

#### 5. 通过帮助文档查看 String 中的方法

| 方法名                                    | 说明                                             |
| ----------------------------------------- | ------------------------------------------------ |
| `public boolean equals (Object anObject)` | 比较字符串的内容，严格区分大小写（用户名和密码） |
| `public char charAt (int index)`          | 返回指定索引处的 char 值                         |
| `public int length()`                     | 返回此字符串的长度                               |

### 3. StringBuilder

#### 1. StringBuilder 概述

StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器

这里的可变指的是 StringBuilder 对象中的内容是可变的

**`String` 和 `StringBuilder` 的区别**

- String：内容是不可变的
- StringBuilder：内容是可变的

#### 2. StringBuilder 构造方法

| 方法名                             | 说明                                       |
| ---------------------------------- | ------------------------------------------ |
| `public StringBuilder()`           | 创建一个空白可变字符串对象，不含有任何内容 |
| `public StringBuilder(String str)` | 根据字符串的内容，来创建可变字符串对象     |

#### 3. StringBuilder 的添加和反转方法

| 方法名                                   | 说明                     |
| ---------------------------------------- | ------------------------ |
| `public StringBuilder append (任意类型)` | 添加数据，并返回对象本身 |
| `public StringBuilder reverse ()`        | 返回相反的字符序列       |

#### 4. StringBuilder 和 String 相互转换

1. StringBuilder 转换为 String

   `public String toString()`：通过 toString()就可以实现把 StringBuilder 转换为 String

2. String 转换为 StringBuilder

   `public StringBuilder(String s)`：通过构造方法就可以实现把 String 转换为 StringBuilder

#### 5. 通过帮助文档查看 StringBuilder 中的方法

| 方法名                                   | 说明                                                     |
| ---------------------------------------- | -------------------------------------------------------- |
| `public StringBuilder append (任意类型)` | 添加数据，并返回对象本身                                 |
| `public StringBuilder reverse ()`        | 返回相反的字符序列                                       |
| `public String toString()`               | 通过 toString() 就可以实现把 StringBuilder 转换为 String |

## 14. 集合基础

### 1. 集合概述

编程的时候如果要存储多个数据，使用长度固定的数组存储格式，不一定满足我们的需求，更适应不了变化的需求，那么此时该如何选择呢？

集合的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变

集合类有很多，目前我们先学习一个：`ArrayList`

`ArrayList<E>`：

- 可调整大小的数组实现
- \<E\> 是一种特殊的数据类型，泛型。

**怎么用呢？**

再出现 E 的地方我们使用引用数据类型替换即可

举例：

- `ArrayList<String>`
- `ArrayList<Student>`

### 2. ArrayList 构造方法和添加方法

| 方法名                                   | 说明                           |
| ---------------------------------------- | ------------------------------ |
| `public ArrayList()`                     | 创建一个空的集合对象           |
| `public boolean add (E e)`               | 将指定的元素追加到此集合的末尾 |
| `public void add (int index, E element)` | 在此集合中的位置插入指定的元素 |

### 3. ArrayList 集合常用方法

| 方法名                                | 说明                                   |
| ------------------------------------- | -------------------------------------- |
| `public boolean remove (Object o)`    | 删除指定的元素，返回删除是否成功       |
| `public E remove (int index)`         | 删除指定索引处的元素，返回被删除的元素 |
| `public E set (int index, E element)` | 修改指定索引处的元素，返回被修改的元素 |
| `public E get (int index)`            | 返回指定索引处的元素                   |
| `public int size ()`                  | 返回集合中的元素个数                   |

## 15. 继承

### 1. 继承概述

继承格式

- 格式：`public class 子类名 extends 父类名 { }`
- 范例：`public class Zi extends Fu { }`
- Fu：是父类，也被称为基类、超类
- Zi：是子类，也被称为派生类

继承中子类的特点：

- 子类可以有父类的内容
- 子类还可以有自己特有的内容

### 2. 继承的好处和弊端

继承的好处

- 提高了代码的**复用性**（多个类相同的成员可以放到同一个类中）
- 提高了代码的**维护性**（如果方法的代码需要修改，修改一处即可）

继承的弊端

- 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性

什么时候使用继承？

- 继承体现的关系：**is a**
- 假设法：我有两个类 A 和 B，如果他们满足 A 是 B 的一种，或者 B 是 A 的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不能滥用继承
- 举例：苹果和水果，猫和动物，猫和狗

### 3. 继承中变量的访问特点

在子类中访问一个变量

- 子类局部范围查找
- 子类成员范围查找
- 父类成员范围查找
- 如果都没有就报错（不考虑父亲的父亲...）

### 4. super

`super` 关键字的用法和 `this` 关键字的用法相似

- `this`：代表本类对象的引用
- `super`：代表父类存储空间的标识（可以理解为父亲对象引用）

::: tip

this 关键字指向调用该方法的对象

一般我们是在当前类中使用 this 关键字，所以我们常说 this 代表本类对象的引用

:::

| 关键字  | 访问成员变量                      | 访问构造方法                  | 访问成员方法                           |
| ------- | --------------------------------- | ----------------------------- | -------------------------------------- |
| `this`  | `this.成员变量` 访问本类成员变量  | `this(...)` 访问本类构造方法  | `this.成员方法(...)` 访问本类成员方法  |
| `super` | `super.成员变量` 访问父类成员变量 | `super(...)` 访问父类构造方法 | `super.成员方法(...)` 访问父类成员方法 |

### 5. 继承中构造方法的访问特点

子类中所有的构造方法默认都会访问父类中无参的构造方法为什么呢?

- 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化
- 每一个子类构造方法的第一条语句默认都是：`super()`

如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢?

- 通过使用 super 关键字去显示的调用父类的带参构造方法

**推荐：自己给出无参构造方法**

### 6. 继承中成员方法的访问特点

通过子类对象访问一个方法

- 子类成员范围找
- 父类成员范围找
- 如果都没有就报错（不考虑父亲的父亲...）

### 7. 方法重写

方法重写概述

- 子类中出现了和父类中一模一样的方法声明

方法重写的应用

- 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容
- 练习：手机类和新手机类

`@Override`

- 是一个注解（注解后面会学习）
- 可以帮助我们检查重写方法的方法声明的正确性

### 8. 方法重写的注意事项

- 私有方法不能被重写（父类私有成员子类是不能继承的）子类方法访问
- 权限不能更低（public > 默认 > 私有）

### 9. Java 中继承的注意事项

- Java 中只支持单继承，不支持多继承
- Java 中类支持多层继承

## 16. 修饰符

### 1. 包

#### 1. 包的概述和使用

其实就是文件夹

作用：对类进行分类管理

包的定义格式

- 格式：`package 包名;` （多级包用的）

带包的 Java 类编译和执行

- 手动建包：

  按照以前的格式编译 Java 文件

  手动创建包

  把 class 文件放到包的最里面

  带包执行

- 自动建包：`java -d HelloWorld.java`

### 2. 导包

使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了

为了简化导包的操作，Java 就提供了导包的功能

导包的格式

- 格式：`import 包名;`

### 3. 修饰符

#### 1. 修饰符的分类

- 权限修饰符
- 状态修饰符

#### 2. 权限修饰符

|   修饰符    | 同一个类中 | 同一个包中子类无关类 | 不同包的子类 | 不同包的无关类 |
| :---------: | :--------: | :------------------: | :----------: | :------------: |
|  `private`  |     ✔      |                      |              |                |
|    默认     |     ✔      |          ✔           |              |                |
| `protected` |     ✔      |          ✔           |      ✔       |                |
|  `public`   |     ✔      |          ✔           |      ✔       |       ✔        |

#### 3. 状态修饰符

- `final`（最终态）
- `static`（静态）

#### 4. final

`final` 关键字是最终的意思，可以修饰成员方法，成员变量，类

`final` 修饰的特点

- 修饰方法：表明该方法是最终方法，**不能被重写**
- 修饰变量：表明该变量是常量，**不能再次被赋值**
- 修饰类：表明该类是最终类，**不能被继承**

#### 5. final 修饰局部变量

变量是基本类型：final 修饰指的是基本类型的**数据值**不能发生改变

变量是引用类型：final 修饰指的是引用类型的**地址值**不能发生改变，但是地址里面的内容是可以发生改变的

#### 6. static

`static` 关键字是静态的意思，可以修饰成员方法，成员变量

`static` 修饰的特点

- 被类的所有对象共享

  这也是我们判断是否使用静态关键字的条件

- 可以通过类名调用

  当然也可以通过对象名调用

  **推荐使用类名调用**

#### 7. static 访问特点

非静态的成员方法

- 能访问静态的成员变量
- 能访问非静态的成员变量
- 能访问静态的成员方法
- 能访问非静态的成员方法

静态的成员方法

- 能访问静态的成员变量
- 能访问静态的成员方法

**总结成一句话就是：静态成员方法只能访问静态成员**

## 17. 多态

### 1. 多态概述

同一个对象，在不同时刻表现出来的不同形态

<br>

举例：猫

我们可以说猫是猫：`猫 cat = new 猫();`

我们也可以说猫是动物：`动物 animal = new 猫();`

这里猫在不同的时刻表现出了不同的形态，这就是多态

<br>

多态的前提和体现

- 有继承/实现关系
- 有方法重写
- 有父类引用指向子类对象

### 2. 多态中成员访问的特点

- **成员变量**：编译看左边，指向看左边
- **成员方法**：编译看左边，执行看右边

<br>

为什么成员变量和成员方法的访问不一样呢？

- 因为成员方法有重写，而成员变量没有

### 3. 多态的好处和弊端

- 多态的好处：提高了程序的扩展性

  具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作

- 多态的弊端：不能使用子类的特有功能

### 4. 多态中的转型

- 向上转型

  从子到父

  父类引用指向子类对象

- 向下转型

  从父到子

  父类引用转为子类对象

## 18. 抽象类

### 1. 抽象类描述

在 Java 中，一个**没有方法体**的方法应该定义为**抽象方法**，而类中如果有**抽象方法**，该类必须定义为**抽象类**

### 2. 抽象类的特点

- 抽象类和抽象方法必须使用 `abstract` 关键字修饰

  `public abstract class 类名{}`

  `public abstract void eat ();`

- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类

- 抽象类不能实例化

  抽象类如何实例化呢？通过子类对象实例化，这也叫抽象类多态

- 抽象类的子类

  要么重写抽象类中的所有抽象方法

  要么是抽象类

### 3. 抽象类的成员特点

- 成员变量

  可以是变量

  也可以是常量

- 构造方法

  有构造方法，但是不能实例化

  那么，构造方法的作用是什么呢？用于子类访问父类数据的初始化

- 成员方法

  可以有抽象方法：限定子类必须完成某些动作

  也可以有非抽象方法：提高代码复用性

## 19. 接口

### 1. 接口概述

接口是一种**公共的规范标准**，只要符合规范标准，大家都可以通用

Java 中的接口更多的体现在**对行为的抽象**

### 2. 接口的特点

- 接口用关键字 `interface` 修饰

  `public interface 接口名 {}`

- 实现接口用 `implements` 表示

  `public class 类名 implements 接口名 {}`

- 接口不能实例化

  接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。

- 接口的实现类

  要么重写接口中的所有抽象方法

  要么是抽象类

### 3. 接口的成员特点

- 成员变量

  只能是常量

  默认修饰符：`public static final`

- 构造方法

  接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在

  一个类如果没有父类，默认继承自 Object 类

- 成员方法

  只能是抽象方法

  默认修饰符：`public abstract`

### 4. 类和接口的关系

- 类和类的关系

  继承关系，只能单继承，但是可以多层继承

- 类和接口的关系

  实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

- 接口和接口的关系

  继承关系，可以单继承，也可以多继承

### 5. 抽象类和接口的区别

- 成员区别

  抽象类：变量，常量；有构造方法，也有非抽象方法

  接口：常量；抽象方法

- 关系区别

  类与类：继承，单继承

  类与接口：实现，可以单实现，也可以多实现

  接口与接口：继承，单继承，多继承

- 设计概念区别

  抽象类：对象抽象，包括属性、行为

  接口：对行为抽象，主要是行为

门和警报的例子

门：都有 `open()` 和 `close()` 两个动作，这个时候，我们可以分别使用抽象类和接口来定义这个抽象概念

```java
//抽象类
public abstract class Door {
    public abstract void open();
    public abstract void close();
}
```

```java
//接口
public interface Door {
    void open();
    void close();
}
```

```java
//抽象类
public abstract class Door {
    public abstract void open();
    public abstract void close();
    public abstract void alarm();
}
```

```java
//接口
public interface Door {
    void open();
    void close();
    void alarm();
}
```

```java
public interface Alarm {
    void alarm();
}
public abstract class Door {
    public abstract void open();
    public abstract void close();
}
public class AlarmDoor extends Door implements Alarm {
    public void open() {
        // ...
    }
    public void close() {
        // ...
    }
    public void alarm() {
        // ...
    }
}
```

在这里，我们再次强调抽象类是对事物的抽象，而接口是对行为的抽象

## 20. 形参和返回值

### 1. 类名作为形参和返回值

- 方法的形参是类名，其实需要的是该类的对象
- 方法的返回值是类名，其实返回的是该类的对象

### 2. 抽象类名作为形参和返回值

- 方法的形参是抽象类名，其实需要的是该抽象类的子类对象
- 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象

### 3.接口名作为形参和返回值

- 方法的形参是接口名，其实需要的是该接口的实现类对象
- 方法的返回值是接口名，其实返回的是该接口的实现类对象

## 21. 内部类

### 1. 内部类概述

内部类：就是一个类中定义一个类。举例：在一个类 A 的内部定义一个类 B，类 B 就被称为内部类

内部类的定义格式：

- 格式：

```java
public class 类名 {
    修饰符 class 类名 {
    }
}
```

- 范例：

```java
public class Outer {
    修饰符 class Inner {
    }
}
```

内部类的访问特点

- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须包括创建对象

### 2. 成员内部类

按照内部类在类中定义的位置不同，可以分为如下两种形式

- 在类的成员位置：成员内部类
- 在类的局部位置：局部内部类

成员内部类，外界如何创建对象使用呢？

- 格式：外部类名.对象名 对象名 = 外部类对象.内部类对象

### 3. 局部内部类

局部内部类是在方法中定义的类，所有外界是无法直接使用，需要在方法内部创建对象并使用

该类可以直接访问外部类的成员，也可以访问方法内部的局部变量

### 4. 匿名内部类

前提：存在一个类或者接口，这里的类可以是具体类也可以是抽象类

- 格式：

```java
new 类名或者接口名() {
    重写方法;
}
```

### 5. 匿名内部类在开发中的使用

```java
/*
	跳高接口
*/
public interface Jumpping {
    void jump();
}
```

```java
/*
	接口操作类，里面有一个方法，方法的参数是接口名
*/
public class JumppingOperator {
    public void method (Jumpping j) {
        j.jump();
    }
}
```

```java
/*
	测试类
*/
public class JumppingDemo {
    public static void main(String[] args) {
        // 需求：创建接口操作类的对象，调用 method 方法
    }
}
```

## 22. 常用 API

### 1. Math

#### 1. Math 类概述

Math 包含执行基本数字运算的方法

<br>

**没有构造方法，如何使用类中的成员呢？**

看类的成员是否都是静态的，如果是，通过类名就可以直接调用

#### 2. Math 类的常用方法

| 方法名                                       | 说明                                             |
| -------------------------------------------- | ------------------------------------------------ |
| public static int abs(int a)                 | 返回参数的绝对值                                 |
| public static double ceil(double a)          | 返回大于或等于参数的最小 double 值，等于一个整数 |
| public static double floor(double a)         | 返回大于或等于参数的最大 double 值，等于一个整数 |
| public static double round(float a)          | 按照四舍五入返回最接近参数的 int                 |
| public static double max(int a, int b)       | 返回两个 int 值中的较大值                        |
| public static double min(int a, int b)       | 返回两个 int 值中的较小值                        |
| public static double pow(double a, double b) | 返回 a 的 b 次幂的值                             |
| public static double random()                | 返回值为 double 的正值，[0.0, 1.0)               |

### 2. System

#### 1. System 类概述

System 包含几个有用的类字段和方法，它不能被实例化

#### 2. System 类的常用方法

| 方法名                                 | 说明                                         |
| -------------------------------------- | -------------------------------------------- |
| public static void exit(int status)    | 终止当前运行的 Java 虚拟机，非零表示异常终止 |
| public static long currentTimeMillis() | 返回当前时间（以毫秒为单位）                 |

### 3. Object

#### 1. Object 类的概述

Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类

构造方法：public Object()

回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法？

因为它们的顶级父类只有无参构造方法

#### 2. Object 类的常用方法

| 方法名                              | 说明                                                       |
| ----------------------------------- | ---------------------------------------------------------- |
| public String toString()            | 返回对象的字符串表示形式。建议所有子类重写该方法，自动生成 |
| public boolean toString(Object obj) | 比较对象是否相等。默认比较地址，重写可以比较内容，自动生成 |

### 4. Arrays

#### 1. 冒泡排序

排序：将一组数据按照固定的规则进行排列

冒泡排序：一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序

- 如果有 n 个数据进行排序，总共需要比较 n-1 次
- 每一次比较完毕，下一次的比较就会少一个数据参与

#### 2. Arrays 类的概述和常用方法

Arrays 类包含用于操作数组的各种方法

| 方法名                                 | 说明                               |
| -------------------------------------- | ---------------------------------- |
| public static String toString(int[] a) | 返回指定数组的内容的字符串表示形式 |
| public static void sort(int[] a)       | 按照数字顺序排列指定的数组         |

工具类的设计思想：

- 构造方法用 private 修饰
- 成员使用 public static 修饰

### 5. 基本类型包装类

#### 1. 基本类型包装类概述

将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据

常用的操作之一：用于基本数据类型与字符串之间的转换

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| char         | Character |
| boolean      | Boolean   |

#### 2. Integer 类的概述和使用

Integer：包装一个对象中的原始类型 int 的值

| 方法名                                  | 说明                                        |
| --------------------------------------- | ------------------------------------------- |
| public Integer(int value)               | 根据 int 值创建 Integer 对象（**过时**）    |
| public Integer(String s)                | 根据 String 值创建 Integer 对象（**过时**） |
| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer 实例        |
| public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String    |

#### 3. int 和 String 的相互转换

基本类型包装类的最常见操作就是：用于基本类型和字符串之间的相互转换

##### 1. int 转换为 String

public static String `valueOf(int i)`：返回 int 参数的字符串表示形式。该方法是 String 类中的方法

##### 2. String 转换为 int

public static `parseInt(String s)`：将字符串解析为 int 类型。该方法是 Integer 类中的方法

#### 4. 自动装箱和拆箱

- 装箱：把基本数据类型转换为对应的包装类型
- 拆箱：把包装类型转换为对应的基本数据类型

```java
Integer i = 200; // 自动装箱
i += 200; // i = i + 200; i + 200 自动拆箱; i = i + 200; 是自动装箱
```

::: warning 注意

在使用包装类型的时候，如果做操作，最好先判断是否为 null

我们推荐的是，**只要是对象，在使用前就必须进行不为 null 的判断**

:::

### 6. 日期类

#### 1. Date 类概述和构造方法

Date 代表了一个特定的时间，精确到毫秒

| 方法名                 | 说明                                                               |
| ---------------------- | ------------------------------------------------------------------ |
| public Date()          | 分配一个 Date 对象，并初始化，以便它代表它被分配的时间，精确到毫秒 |
| public Date(long date) | 分配一个 Date 对象，并将其初始化为表示从标准基准时间起指定的毫秒数 |

#### 2. Date 类的常用方法

| 方法名                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| public long getTime()          | 获取的是日期对象从 1970 年 1 月 1 日 00:00:00 到现在的毫秒值 |
| public void setTime(long time) | 设置时间，给的是毫秒值                                       |

#### 3. SimpleDateFormat 类概述

SimpleDateFormat 是一个具体的类，用于区域设置敏感的方式格式化和解析时间。我们重点学习**日期格式化和解析**

日期和时间个还是是由日期和时间模式字符串指定，在日期和时间模式字符串中，从 'A' 到 'Z' 以及从 'a' 到 'z' 引号的字母被解释为表示日期或时间字符串的组件的模式字母

常用的模式字母及对应关系如下：

| 字母 | 模式 |
| ---- | ---- |
| y    | 年   |
| M    | 月   |
| d    | 日   |
| H    | 时   |
| m    | 分   |
| s    | 秒   |

#### 4. SimpleDateFormat 的构造方法

| 方法名                                  | 说明                                                     |
| --------------------------------------- | -------------------------------------------------------- |
| public SimpleDateFormat()               | 构造一个 SimpleDateFormat，使用默认模式和日期格式        |
| public SimpleDateFormat(String pattern) | 构造一个 SimpleDateFormat 使用给定的模式和默认的日期格式 |

#### 5. Calendar 类概述

Calendar 为某一时刻和一组日历之间的转换提供了一些方法，并为操作日历字段提供了一些方法

Calendar 提供了一个类方法 getInstance 用于获取 Calendar 对象，其日历字段已使用当前日期和时间初始化：

Calendar rightNow = Calendar.getInstance();

#### 6. calendar 的常用方法

| 方法名                                      | 说明                                                   |
| ------------------------------------------- | ------------------------------------------------------ |
| public int get(int field)                   | 返回给定日历字段的值                                   |
| public abstract void(int field, int amount) | 根据日历的规则，将指定的时间量添加或减去给定的日历字段 |
| public final void set(int year, int date)   | 设置当前日历的年月日                                   |

## 23. 异常

### 1. 异常概述

异常：就是程序出现了不正常的情况

#### 异常体系

Throwable

- Error
- Exception
  - RuntimeException
  - 非 RuntimeException

Error：严重问题，不需要处理

Exception：称为异常类，它表示程序本身可以处理的问题

- RuntimeException：在编译期是不检查的，出现问题后，需要我们回来修改代码
- 非 RuntimeException：编译器就必须处理的，否则程序不能通过编译，就更不能正常运行了

### 2. JVM 的默认处理方案

如果程序出现了问题，我们没有做任何处理，最终 JVM 会做出默认的处理

- 把异常的名称，异常原因及异常出现的位置等信息输出在了控制台
- 程序停止运行

### 3. 异常处理

如果程序出现了问题，我们需要自己来处理，有两种方案：

- try ... catch ...
- throws

### 4. 异常处理之 try ... catch ...

格式：

```java
try {
    可能出现异常的代码;
} catch(异常类名 变量名) {
    异常的处理代码;
}
```

执行流程：

程序从 try 里面的代码开始执行

出现异常，会自动生成一个异常类对象，该异常对象将被提交给 Java 运行时系统

当 Java 运行时系统接收到异常对象时，回到 catch 中去找匹配的异常类，找到后进行异常的处理

执行完毕之后，程序还可以继续往下执行

### 5. Throwable 的成员方法

| 方法名                         | 说明                              |
| ------------------------------ | --------------------------------- |
| public String getMessage()     | 返回此 throwable 的详细消息字符串 |
| public String toString()       | 返回此可抛出的简短描述            |
| public void printStackTrance() | 把异常的错误信息输出在控制台      |

### 6. 编译时异常和运行时异常的区别

Java 中的异常被分为两大类：**编译时异常**和**运行时异常**，也被称为**受检异常**和**非受检异常**

所有的 RuntimeException 类及其子类被称为运行时异常，其他的异常都是编译时异常

- 编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译
- 运行时异常：无需显示处理，也可以和编译时异常一样处理

### 7. 异常处理之 throws

虽然我们通过 try ... catch ... 可以对异常进行处理，但是并不是所有的情况都有权限进行异常的处理

也就是说，有些时候可能出现的异常是我们处理不了的，这个时候该怎么办呢？

针对这种情况，Java 提供了 throws 的处理方案

格式：

```java
throws 异常类名;
```

::: warning 注意

这个格式是跟在方法的括号后面的

:::

- **编译时异常必须要进行处理**，两种处理方案：try ... catch 或者 throws，如果采用 throws 这种方案，将来谁调用谁处理
- **运行时异常可以不处理**，出现问题后，需要我们回来修改代码

### 8. 自定义异常

格式：

```java
public class 异常类名 extends Exception {
    // 无参构造
    // 带参构造
}
```

### 9. throws 和 throw 的区别

#### throws

- 用在方法声明后面，跟的是异常类名
- 表示抛出异常，由该方法的调用者来处理
- 表示出现异常的一种可能性，并不一定会发生这些异常

#### throw

- 用在方法体内，跟的是异常对象名
- 表示抛出异常，由方法体内部的语句处理
- 执行 throw 一定抛出了某种异常

## 24. 集合进阶

### 1. Collection

#### 1. 集合知识回顾

集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变

#### 2. 集合体系结构

- Collection（单列）
  - List（可重复）
    - ArrayList
    - LinkedList
    - ......
  - Set（不可重复）
    - HashSet
    - TreeSet
    - ......
- Map（双列）
  - HashMap
  - ......

接口

实现类

#### 3. Collection 结合概述和使用

Collection 集合概述

- 是单例集合的顶层接口，它表示一组对象，这些对象也称为 Collection 的元素
- JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如 Set 和 List）实现

创建 Collection 集合的对象

- 多态的方式
- 具体的实现类 ArrayList

#### 4. Collection 集合常用方法

| 方法名                     | 说明                               |
| -------------------------- | ---------------------------------- |
| boolean add(E e)           | 添加元素                           |
| boolean remove(Object o)   | 从集合中移除指定的元素             |
| void clear()               | 清空集合中的元素                   |
| boolean contains(Object o) | 判断集合中是否出现指定的元素       |
| boolean isEmpty()          | 判断集合是否为空                   |
| int size()                 | 集合的长度，也就是集合中元素的个数 |

#### 5. Collection 集合的遍历

Iterator：迭代器，集合的专用遍历方式

- Iterator \<E\> iterator()：返回此集合中元素的迭代器，通过集合的 iterator() 方法得到
- 迭代器是通过集合的 iterator() 方法得到的，所以说它是依赖于集合而存在的

Iterator 中的常用方法

- E next()：返回迭代中的下一个元素
- boolean hasNext()：如果迭代具有更多元素，则返回 true

### 2. List

#### 1. List 集合概述和特点

List 集合概述

- 有序集合（也称为序列），用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素
- 与 Set 集合不同，列表通常允许重复的元素

List 集合特点

- 有序：存储和取出的元素顺序一致
- 可重复：存储的元素可以重复

#### 2. List 集合特有方法

| 方法名                        | 说明                                   |
| ----------------------------- | -------------------------------------- |
| void ad(int index, E element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int index)           | 删除指定索引处的元素，返回删除的元素   |
| E set(int index, E element)   | 修改指定索引处的元素，返回被修改的元素 |
| E get(int index)              | 返回指定索引处的元素                   |

#### 3. 并发修改异常

并发修改异常

- ConcurrentModificationException

产生原因

- 迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中预期修改值和实际修改值不一致

解决方案

- 用 for 循环遍历，然后用集合对象做对应的操作即可

#### 4. ListIterator

ListIterator：列表迭代器

- 通过 List 集合的 listIterator() 方法得到，所以说它是 List 集合特有的迭代器
- 用于允许程序员沿任何一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置

ListIterator 中的常用方法

- E next()：返回迭代中的下一个元素
- boolean hasNext()：如果迭代具有更多元素，则返回 true
- E previous()：返回列表中的上一个元素
- boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回 true
- void add(E e)：将指定的元素插入列表

#### 5. 增强 for 循环

增强 for：简化数组和 Collection 集合的遍历

- 实现 Iterator 接口的类允许其对象称为增强型 for 语句的目标
- 它是 JDK5 之后出现的，其内部原理是一个 Iterator 迭代器

增强 for 的格式

- 格式：

```java
for(元素数据类型 遍历名 : 数组或者 Collection 集合) {
    // 在此处使用变量即可，该变量就是元素
}
```

#### 6. 数据结构

数据结构是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合

通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率

#### 7. 常见的数据结构之栈

数据进入栈模型的过程称为：**压/进栈**

数据离开栈模型的过程称为：**弹/出栈**

栈是一种数据**先进后出**的模型

#### 8. 常见数据结构之队列

数据从**后端**进入队列模型的过程称为：**入队列**

数据从**前端**离开队列模型的过程称为：**出队列**

队列是一种数据**先进先出**的模型

#### 9. 常见数据结构之数组

查询数据通过索引定位，查询任意数据耗时相同，**查询效率高**

删除数据时，要将原始数据删除，同时后面每个数据前移，**删除效率低**

添加数据时，添加位置后的每个数据后移，再添加元素，**添加效率极低**

#### 10. 常见数据结构之链表

链表是一种**增删快**的模型（对比数组）

链表是一种**查询慢**的模型（对比数组）

#### 11. List 集合子类特点

List 集合常用子类：ArrayList，LinkedList

- ArrayList：底层数据结构是数组，查询快，增删慢
- LinkedList：底层数据结构是链表，查询慢，增删快

#### 12. LinkedList 集合的特有功能

| 方法名                    | 说明                             |
| ------------------------- | -------------------------------- |
| public void addFirst(E e) | 在该列表开头插入指定的元素       |
| public void addLast(E e)  | 将指定的元素追加到此列表的末尾   |
| public E getFirst()       | 返回此列表中的第一个元素         |
| public E getLast()        | 返回此列表中的最后一个元素       |
| public E removeFirst()    | 从此列表中删除并返回第一个元素   |
| public E removeLast()     | 从此列表中删除并返回最后一个元素 |

### 3. Set

#### 1. Set 集合概述和特点

Set 集合特点

- 不包含重复元素的集合
- 没有带索引的方法，所以不能使用普通 for 循环遍历

#### 2. 哈希值

哈希值：是 JDK 根据对象的**地址**或者**字符串**或者**数字**算出来的 int 类型的**数值**

Object 类中有一个方法可以获取**对象的哈希值**

- public int hashCode()：返回对象的哈希码值

对象的哈希值特点

- 同一个对象多次调用 hashCode() 方法返回的哈希值是相同的
- 默认情况下，不同对象的哈希值是不同的。而重写 hashCode 方法，可以实现让不同对象的哈希值相同

#### 3. HashSet 集合概述和特点

HashSet 集合特点

- 底层数据结构是哈希表
- 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致
- 没有带索引的方法，所以不能使用普通 for 循环遍历
- 由于是 Set 集合，所以不包含重复元素的集合

#### 4. HashSet 集合保证元素唯一性源码分析

HashSet 集合添加一个元素的过程：

HashSet 集合存储元素：

- 要保证元素唯一性，需要重写 `hashCode()` 和 `equals()`

#### 5. 常见数据结构之哈希表

哈希表

- JDK8 之前，底层采用**数组 + 链表**实现，可以说是一个元素为链表的数组
- JDK8 之后，在长度比较长的时候，底层实现了优化

#### 6. LinkedHashSet 集合概述和特点

LinkedHashSet 集合特点

- 哈希表和链表实现的 Set 接口，具有可预测的迭代次序
- 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的
- 由哈希表保证元素唯一，也就是说没有重复的元素

#### 7. TreeSet 集合概述和特点

TreeSet 集合特点

- 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法

  TreeSet()：根据其元素的自然排序进行排序

  TreeSet(Comparator comparator)：根据指定的比较器进行排序

- 没有带索引的方法，所以不能使用普通 for 循环循环遍历

- 由于是 Set 集合，所以不包含重复元素的集合

#### 8. 自然排序 Comparable 的使用

- 存储学生对象并遍历，创建 TreeSet 集合使用**无参构造方法**
- 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序

结论

- 用 TreeSet 集合存储自定义对象，无参构造方法使用的是**自然排序**对元素进行排序的
- 自然排序，就是**让元素所属的类实现 Comparable 接口**，重写 compareTo(To) 方法
- 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写

#### 9. 比较器排序 Comparator 的使用

- 存储学生对象并遍历，创建 TreeSet 集合使用**带参构造方法**
- 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序

结论

- 用 TreeSet 集合存储自定义对象，带参构造方法使用的是**比较器排序**对元素进行排序的
- 比较器排序，就是**让集合构造方法接收 Comparator 的实现类对象**，重写 compare(T o1, T o2) 方法
- 重写方法时，一定要注意排序必须按照要求的主要条件和次要条件来写

### 4. 泛型

#### 1. 泛型概述

泛型：是 JDK5 中注入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型

它的本质是**参数化类型**，也就是说所操作的数据类型被指定为一个参数

一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？

顾名思义，就是**将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型**

这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口

泛型定义格式：

- \<类型\>：指定一种类型的格式。这里的类型可以看成是形参
- \<类型 1, 类型 2 ...\>：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参
- 将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型

泛型的好处：

- 把运行时期的问题提前到了编译期间
- 避免了强制类型转换

#### 2. 泛型类

泛型类的定义格式：

- 格式：修饰符 class 类名 \<类型\> { }

  此处 **T** 可以随便写为任意标识，常见的如 **T、E、K、V** 等形式的参数常用于表示泛型

#### 3. 泛型方法

泛型方法的定义格式：

- 格式：修饰符 \<类型\> 返回值类型 方法名(类型 变量名) { }

#### 4. 泛型接口

泛型接口的定义格式：

- 格式：修饰符 interface 接口名 \<类型\> { }

#### 5. 类型通配符

为了表示各种泛型 List 的父类，可以使用类型通配符

- 类型通配符：**\<?\>**
- List<?>：表示元素类型未知的 List，它的元素可以匹配**任何的类型**
- 这种带通配符的 List 仅表示它是各种泛型 List 的父亲，并不能把元素添加到其中

如果说我们不希望 List\<?\> 是任何泛型 List 的父类，只希望它代表某一类泛型 List 的父类，可以使用类型通配符的上限

- 类型通配符上限：**\<? extends 类型\>**
- List\<? extends Number\>：它表示的类型是 **Number 或者其子类型**

除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限

- 类型通配符下限：**\<? super 类型\>**
- List\<? super Number\>：它表示的类型是 **Number 或者其父类型**

#### 6. 可变参数

可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了

- 格式：修饰符 返回值类型 方法名(数据类型 ... 变量名) { }

可变参数注意事项

- 这里的变量其实是一个数组
- 如果一个方法有多个参数，包含可变参数，**可变参数要放在最后**

#### 7. 可变参数的使用

Arrays 工具类中有一个静态方法：

- public static \<T\> List \<T\> asList(T ... a)：返回由指定数组支持的固定大小的列表
- 返回的集合不能做增删操作，可以做修改操作

List 接口中有一个静态方法：

- public static \<E\> List\<E\> of(E ... elements)：返回包含任意数量元素的不可变列表
- 返回的集合不能做增删改操作

Set 接口中有一个静态方法：

- public static \<E\> Set of(E ... elements)：返回一个包含任意数量元素的不可变集合
- 在给元素的时候，不能给重复的元素
- 返回的集合不能做增删操作，没有修改的方法

### 5. Map

#### 1. Map 集合概述和使用

Map 集合概述

- Interface Map \<K, V\> K：键的类型；V：值的类型
- 将键映射到值的对象；不能包含重复的键；每个键可以映射到最多一个值

创建 Map 集合的对象

- 多态的方式
- 具体的实现类 HashMap

#### 2. Map 集合的基本功能

| 方法名                              | 说明                                 |
| ----------------------------------- | ------------------------------------ |
| V put(K key,V value)                | 添加元素                             |
| V remove(Object key)                | 根据键删除键值对元素                 |
| void clear()                        | 移除所有的键值对元素                 |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |
| boolean containsValue(Object value) | 判断集合是否包含指定的值             |
| boolean isEmpty()                   | 判断集合是否为空                     |
| int size()                          | 集合的长度，也就是集合中键值对的个数 |

#### 3. Map 集合的获取功能

| 方法名                                  | 说明                         |
| --------------------------------------- | ---------------------------- |
| V get(Object key)                       | 根据键获取值                 |
| Set\<K\> keySet()                       | 获取所有键的集合             |
| Collection\<V\> values()                | 获取所有值的集合             |
| **Set\<Map.Entry\<K, V\>\> entrySet()** | **获取随意键值对对象的集合** |

#### 4. Map 集合的遍历（方式 1）

我们刚才存储的元素都是成对出现的，所以我们把 Map 看成是一个夫妻对的集合

遍历思路

- 把所有的丈夫给集中起来
- 遍历丈夫的集合，获取到每一个丈夫

转换为 Map 集合中的操作：

- 获取所有键的集合。用 keySet() 方法实现
- 遍历键的集合，获取到每一个键。用增强 for 实现
- 根据键去找值。用 get(Object key) 方法实现

#### 5. Map 集合的遍历（方式 2）

我们刚才存储的元素都是成对出现的，所以我们把 Map 看成是一个夫妻对的集合

遍历思路

- 获取所有结婚证的集合
- 遍历结婚证的集合，得到每一个结婚证
- 根据结婚证获取丈夫和妻子

转换为 Map 集合中的操作：

- 获取所有键值对对象的集合

  **Set \<Map.Entry\<K, V\>\> entrySet()：获取所有键值对的集合**

- 遍历键值对对象的集合，得到每一个键值对对象

  用增强 for 实现，得到每一个 **Map.Entry**

- 根据键值对对象获取键和值

  用 **getKey()** 得到键

  用 **getValue()** 得到值

### 6. Collections

#### 1. Collections 概述和使用

Collections 类的概述

- 是针对集合操作的工具类

Collections 类的常用方法

- public static \<T extends Comparable\<? super T\>\> void sort(List\<T\> list)：将指定的列表按升序排序
- public static void reverse(List\<?\> list)：反转指定列表中元素的顺序
- public static void shuffle(List\<?\> list)：使用默认的随机源随机排列指定的列表
